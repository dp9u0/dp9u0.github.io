<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[sql server 锁]]></title>
      <url>%2F2017%2F03%2F21%2Fsql-server-locks%2F</url>
      <content type="text"><![CDATA[介绍SQL Server 的锁 目录 准备 关于锁 锁资源和兼容性 sqlserver事务隔离级别 事务隔离级别和锁释放 监视锁释放 实际查询中锁的申请与释放 SELECT UPDATE DELETE INSERT #准备 下载巨硬提供的AdventureWorks,下载的是2014版本.是bak文件，直接恢复数据库就可以了. 如果比较旧的版本，例如2008R2，提供的是下载的是 mdf和ldf.可以用CRTEATE DATABASE 命令，从文件创建： 12CREATE DATABASE AdventureWorksON (FILENAME = 'C:\Data\AdventureWorks2008R2_Data.mdf'), (FILENAME = 'C:\Data\AdventureWorks2008R2_Log.ldf') FOR ATTACH; 创建完成后，创建需要的表： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980----------------------------------------------B树表聚集索引表-------------------------------------------USE [AdventureWorks]GOIF EXISTS ( SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Employee_Demo_BTree') DROP TABLE Employee_Demo_BTreeGOCREATE TABLE Employee_Demo_BTree( EmployeeID INT NOT NULL PRIMARY KEY, NationalIDNumber NVARCHAR(15) NOT NULL, ContactID INT NOT NULL, LoginID NVARCHAR(256) NOT NULL, ManagerID INT NULL, Title NVARCHAR(50) NOT NULL, BirthDate DATETIME NOT NULL, MaritalStatus NCHAR(1) NOT NULL, Gender NCHAR(1) NOT NULL, HireDate DATETIME NOT NULL, ModifiedDate DATETIME NOT NULL DEFAULT GETDATE())GO--主键就已经是聚集索引了,无需再指定--CREATE CLUSTERED INDEX PK_Employee_EmployeeID_Demo_BTree ON Employee_Demo_BTree(EmployeeID ASC)--添加非聚集索引CREATE NONCLUSTERED INDEX IX_Employee_ManagerID_Demo_BTree ON Employee_Demo_BTree([ManagerID] ASC)CREATE NONCLUSTERED INDEX IX_Employee_ModifiedDate_Demo_BTree ON Employee_Demo_BTree( [ModifiedDate] ASC)--插入数据INSERT [dbo].[Employee_Demo_BTree] SELECT [BusinessEntityID], [NationalIDNumber], [BusinessEntityID]+100, [LoginID], [BusinessEntityID]%50, [JobTitle], [BirthDate], [MaritalStatus], [Gender], [HireDate], [ModifiedDate] FROM [HumanResources].[Employee]GO----------------------------------------------堆表非聚集索引表-------------------------------------------USE [AdventureWorks]GOIF EXISTS(SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Employee_Demo_Heap') DROP TABLE Employee_Demo_HeapGOCREATE TABLE Employee_Demo_Heap( EmployeeID INT NOT NULL, NationalIDNumber NVARCHAR(15) NOT NULL, ContactID INT NOT NULL, LoginID NVARCHAR(256) NOT NULL, ManagerID INT NULL, Title NVARCHAR(50) NOT NULL, BirthDate DATETIME NOT NULL, MaritalStatus NCHAR(1) NOT NULL, Gender NCHAR(1) NOT NULL, HireDate DATETIME NOT NULL, ModifiedDate DATETIME NOT NULL DEFAULT GETDATE())GO--因为没有主键所以要指定非聚集索引CREATE NONCLUSTERED INDEX PK_Employee_EmployeeID_Demo_Heap ON Employee_Demo_Heap( [EmployeeID] ASC)--添加非聚集索引CREATE NONCLUSTERED INDEX IX_Employee_ManagerID_Demo_Heap ON Employee_Demo_BTree([ManagerID] ASC)CREATE NONCLUSTERED INDEX IX_Employee_ModifiedDate_Demo_Heap ON Employee_Demo_BTree( [ModifiedDate] ASC)--插入数据INSERT [dbo].[Employee_Demo_Heap] SELECT [BusinessEntityID], [NationalIDNumber], [BusinessEntityID]+100, [LoginID], [BusinessEntityID]%50, [JobTitle], [BirthDate], [MaritalStatus], [Gender], [HireDate], [ModifiedDate] FROM [HumanResources].[Employee]GO 关于锁锁资源和兼容性sqlserver事务隔离级别事务隔离级别和锁释放监视锁释放实际查询中锁的申请与释放SELECTUPDATEDELETEINSERT]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL Server基本管理单位:区(Extend)]]></title>
      <url>%2F2017%2F03%2F21%2Fsql-server-extend-management%2F</url>
      <content type="text"><![CDATA[区就是一组8个页(8K),因此区是64k的块。SQL Server内部有2类区： 混合区 统一区]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[02.SQL Server存储单位:页(Page)]]></title>
      <url>%2F2017%2F03%2F01%2Fdata-pages-the-foundation-of-sql-server%2F</url>
      <content type="text"><![CDATA[SQL Server 基本存储单位是页，一个页大小为8K。页分为不同的类型： 1 Data page 堆表和聚集索引的叶子节点数据2 Index page 聚集索引的非叶子节点和非聚集索引的所有索引记录3 Text mixed page A text page that holds small chunks of LOB values plus internal parts of text tree. These can be shared between LOB values in the same partition of an index or heap.4 Text tree page A text page that holds large chunks of LOB values from a single column value.7 Sort page 排序时所用到的临时页，排序中间操作存储数据用的。8 GAM page 全局分配映射（Global Allocation Map，GAM）页面 这些页面记录了哪些区已经被分配并用作何种用途。9 SGAM page 共享全局分配映射（Shared Global Allocation Map，GAM）页面 这些页面记录了哪些区当前被用作混合类型的区，并且这些区需含有至少一个未使用的页面。10 IAM page 有关每个分配单元中表或索引所使用的区的信息11 PFS page 有关页分配和页的可用空间的信息13 boot page 记录了关于数据库的信息，仅存于每个数据库的第9页15 file header page 记录了关于数据库文件的信息，存于每个数据库文件的第0页16 DCM page 记录自从上次全备以来的数据改变的页面，以备差异备份17 BCM page 有关每个分配单元中自最后一条 BACKUP LOG 语句之后的大容量操作所修改的区的信息 123456789101112131415161718192021222324252627282930USE [Test]GOif exists (select * from sysobjects where id = object_id(N'[dbo].[Customers]') and OBJECTPROPERTY(id, N'IsUserTable') = 1 )DROP TABLE dbo.CustomersCREATE TABLE Customers( FirstName CHAR(50) NOT NULL, LastName CHAR(50) NOT NULL, Address CHAR(100) NOT NULL, ZipCode CHAR(5) NOT NULL, Rating INT NOT NULL, ModifiedDate DATETIME NOT NULL,)GOINSERT INTO dbo.Customers ( FirstName , LastName , Address , ZipCode , Rating , ModifiedDate )VALUES ( 'Philip' , 'Aschenbrenner' , 'Pichlagasse 16/6' , '1220' , 1 , '2015-03-25 02:22:51' )GO DBCC IND 命令用于查询一个存储对象的内部存储结构信息，该命令有4个参数, 前3个参数必须指定。语法如下：DBCC IND ( { ‘dbname’ | dbid }, { ‘objname’ | objid },{ nonclustered indid | 1 | 0 | -1 | -2 } [, partition_number] )第一个参数是数据库名或数据库ID。第二个参数是数据库中的对象名或对象ID，对象可以是表或者索引视图。第三个参数是一个非聚集索引ID或者 1, 0, 1, or 2. 值的含义： 0: 只显示对象的in-row data页和 in-row IAM 页。 1: 显示对象的全部页, 包含IAM 页, in-row数据页, LOB 数据页row-overflow 数据页 . 如果请求的对象含有聚集所以则索引页也包括。 -1: 显示全部IAM页,数据页, 索引页 也包括 LOB 和row-overflow 数据页。 -2: 显示全部IAM页。 Nonclustered index ID:显示索引的全部 IAM页, data页和索引页，包含LOB和 row-overflow数据页。为了兼容sql server 2000,第四个参数是可选的,该参数用于指定一个分区号.如果不给定值或者给定0, 则显示全部分区数据。和DBCC PAGE不同的是, SQL Server运行DBCC IND不需要开启3604跟踪标志.结果中 Page type: 1 = data page, 2 = index page, 3 = LOB_MIXED_PAGE, 4 = LOB_TREE_PAGE, 10 = IAM page 1DBCC IND('InternalStorageFormat','Customers',-1) 结果如下： PageFID PagePID IAMFID IAMPID ObjectID 1 150 NULL NULL 261575970 1 147 1 150 261575970 IndexID PartitionNumber PartitionID iam_chain_type PageType 0 1 72057594040614912 In-row data 10 0 1 72057594040614912 In-row data 1 IndexLevel NextPageFID NextPagePID PrevPageFID PrevPagePID NULL 0 0 0 0 0 0 0 0 0 DBCC Page 命令读取数据页结构的命令DBCC Page。该命令为非文档化的命令，具体如下： DBCC Page ({dbid|dbname},filenum,pagenum[,printopt]) 具体参数描述如下： dbid 包含页面的数据库ID dbname 包含页面的数据库的名称 filenum 包含页面的文件编号 pagenum 文件内的页面 printopt 可选的输出选项;选用其中一个值： 0:默认值，输出缓冲区的标题和页面标题 1:输出缓冲区的标题、页面标题(分别输出每一行)，以及行偏移量表 2:输出缓冲区的标题、页面标题(整体输出页面)，以及行偏移量表 3:输出缓冲区的标题、页面标题(分别输出每一行)，以及行偏移量表;每一行后跟分别列出的它的列值 要想看到这些输出的结果，还需要设置DBCC TRACEON(3604)。可以使用 WITH TABLERESULTS 显示成表格化的数据形式 123DBCC TRACEON(3604)DBCC PAGE(InternalStorageFormat,1,41,1) GO 结果如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162DBCC 执行完毕。如果 DBCC 输出了错误信息，请与系统管理员联系。PAGE: (1:147)BUFFER:BUF @0x00000001FEEBDEC0bpage = 0x0000000184E2E000 bhash = 0x0000000000000000 bpageno = (1:147)bdbid = 16 breferences = 0 bcputicks = 0bsampleCount = 0 bUse1 = 36342 bstat = 0xbblog = 0x215acccc bnext = 0x0000000000000000 PAGE HEADER:Page @0x0000000184E2E000m_pageId = (1:147) m_headerVersion = 1 m_type = 1m_typeFlagBits = 0x0 m_level = 0 m_flagBits = 0x8000m_objId (AllocUnitId.idObj) = 121 m_indexId (AllocUnitId.idInd) = 256 Metadata: AllocUnitId = 72057594045857792 Metadata: PartitionId = 72057594040614912 Metadata: IndexId = 0Metadata: ObjectId = 261575970 m_prevPage = (0:0) m_nextPage = (0:0)pminlen = 221 m_slotCnt = 1 m_freeCnt = 7870m_freeData = 320 m_reservedCnt = 0 m_lsn = (34:364:23)m_xactReserved = 0 m_xdesId = (0:0) m_ghostRecCnt = 0m_tornBits = 0 DB Frag ID = 1 Allocation StatusGAM (1:2) = ALLOCATED SGAM (1:3) = ALLOCATED PFS (1:1) = 0x61 MIXED_EXT ALLOCATED 50_PCT_FULL DIFF (1:6) = CHANGEDML (1:7) = NOT MIN_LOGGED Slot 0 Offset 0x60 Length 224Record Type = PRIMARY_RECORD Record Attributes = NULL_BITMAP Record Size = 224Memory Dump @0x0000000011C7A0600000000000000000: 1000dd00 576f6f64 79202020 20202020 20202020 ....Woody 0000000000000014: 20202020 20202020 20202020 20202020 20202020 0000000000000028: 20202020 20202020 20202020 20205475 20202020 Tu 000000000000003C: 20202020 20202020 20202020 20202020 20202020 0000000000000050: 20202020 20202020 20202020 20202020 20202020 0000000000000064: 20202020 5a554f51 49414f20 594f5558 4920544f ZUOQIAO YOUXI TO0000000000000078: 574e204c 494e4841 49204349 54592020 20202020 WN LINHAI CITY 000000000000008C: 20202020 20202020 20202020 20202020 20202020 00000000000000A0: 20202020 20202020 20202020 20202020 20202020 00000000000000B4: 20202020 20202020 20202020 20202020 20202020 00000000000000C8: 20202020 30303030 20010000 001480a7 0091a400 0000 ...........00000000000000DC: 00060000 .... Slot 0 Column 1 Offset 0x4 Length 50 Length (physical) 50FirstName = WoodySlot 0 Column 2 Offset 0x36 Length 50 Length (physical) 50LastName = Tu Slot 0 Column 3 Offset 0x68 Length 100 Length (physical) 100Address = ZUOQIAO YOUXI TOWN LINHAI CITY Slot 0 Column 4 Offset 0xcc Length 5 Length (physical) 5ZipCode = 0000 Slot 0 Column 5 Offset 0xd1 Length 4 Length (physical) 4Rating = 1 Slot 0 Column 6 Offset 0xd5 Length 8 Length (physical) 8ModifiedDate = 2015-05-07 10:09:51.000 OFFSET TABLE:Row - Offset 0 (0x0) - 96 (0x60) DBCC 执行完毕。如果 DBCC 输出了错误信息，请与系统管理员联系。 Page @0x08F84000 同BUFFER中的bpage地址m_pageId = (1:79) 数据页号m_headerVersion = 1 头文件版本号，一直为1m_type = 1 页面类型，1为数据页面m_typeFlagBits = 0x4 数据页和索引页为4，其他页为0m_level = 0 该页在索引页（B树）中的级数m_flagBits = 0x8000 页面标志m_objId (AllocUnitId.idObj) = 46 同Metadata: ObjectIdm_indexId (AllocUnitId.idInd) = 256 同Metadata: IndexIdMetadata: AllocUnitId = 72057594040942592 存储单元的ID,sys.allocation_units.allocation_unit_idMetadata: PartitionId = 72057594039304192 数据页所在的分区号，sys.partitions.partition_idMetadata: IndexId = 0 页面的索引号，sys.objects.object_id&amp;sys.indexes.index_idMetadata: ObjectId = 277576027 该页面所属的对象的id，sys.objects.object_idm_prevPage = (0:0) 该数据页的前一页面；主要用在数据页、索引页和IAM页m_nextPage = (0:0) 该数据页的后一页面；主要用在数据页、索引页和IAM页pminlen = 221 定长数据所占的字节数m_slotCnt = 2 页面中的数据的行数m_freeCnt = 7644 页面中剩余的空间m_freeData = 544 从第一个字节到最后一个字节的空间字节数m_reservedCnt = 0 活动事务释放的字节数m_lsn = (255:8406:2) 日志记录号m_xactReserved = 0 最新加入到m_reservedCnt领域的字节数m_xdesId = (0:0) 添加到m_reservedCnt的最近的事务idm_ghostRecCnt = 0 幻影数据的行数m_tornBits = 0 页的校验位或者被由数据库页面保护形式决定分页保护位取代 GAM (1:2) = ALLOCATED 在GAM页上的分配情况SGAM (1:3) = ALLOCATED 在SGAM页上的分配情况PFS (1:1) = 0x61 MIXED_EXT ALLOCATED 50_PCT_FULL 在PFS页上的分配情况，该页为50%满，DIFF (1:6) = CHANGEDML (1:7) = NOT MIN_LOGGED 查看空间占用情况free_space_in_bytes 表示在指定页面当前有多少空间是可用的。 1SELECT * FROM sys.dm_os_buffer_descriptors 下面这个查询可以告诉你在你的数据库实例里每个数据有多少空间被浪费，可以找出哪个数据库有糟糕的表设计。12345678SELECTDB_NAME(database_id),SUM(free_space_in_bytes) / 1024 AS 'Free_KB'FROM sys.dm_os_buffer_descriptorsWHERE database_id &lt;&gt; 32767GROUP BY database_idORDER BY SUM(free_space_in_bytes) DESCGO 第1个页，页号0，是文件头（page type 15）。它保存着文件头信息。每个数据文件只有一个文件头页，而且是第0页的位置。文件头页里保存着数据文件信息，例如文件大小，最小大小，最大大小和文件增长方式等。 第2个页，页号1，是第一个PFS页（page type 11）。PFS页在数据文件里是第2个页（页号1），紧跟在文件头后（页号0）。GAM和SGAM用来跟踪区分配状态，PFS页用来跟踪页分配级别。当分配页面的时候，数据库引擎使用GAM和SGAM来识别有空页的区。一旦数据库引擎找到有空页的区，它使用PFS页来识别区里空页的可用空间量。可用空间只在保存LOB值（ie text/image, varchar(max),nvarchar(max),varbinary(max) ,row overflow data）或堆表页时跟踪。默认情况下，LOB数据保存在一个独立的页，在原页保存一个指向独立页的指针。这些就是数据能够保存的空页。对于索引页，因为数据的保存顺序和索引顺序是一致的，因此没有必用使用到PFS页。PFS页每8088个页重复一个。这就是说第1页，第8088页，第16176页，第24264页……在每个数据文件里都是PFS页。SQL Server： 理解PFS页。 第3个页，页号2，是第一个GAM页（page type 8）。GAM页用来跟踪哪些区被使用。每个区对应GAM页的一个位。如果这个位的值是1，对应区是空、可用的，如果这个位的值是0，对应区是作为统一区或混合区使用。一个GAM页可以保存接近64000个区的信息。那就是说，一个GAM页可以保存（64000 8 8）/1024 = 4000 MB的信息。简而言之，一个7GB大小的数据文件将有2个GAM页。SQL Server ： 理解GAM与SGAM页。 第4个页，页号3，是第一个SGAM页（page type 9）。SGAM页用来跟踪哪些区正作为混合区使用且至少有一个可用页。每个区对应一个GAM页的有一个位。如果这个位的值是1，对应区作为混合区使用且至少有个可用页，如果这个位值是0，对应区没作为混合区使用或所有页作为混合区使用了。一个SGAM页可以保存接近64000个区的信息。那就是说，一个SGAM页可以保存64000 8 8 /1024 =4000MB。简而言之，一个7GB大小的数据文件将有2个SGAM页。SQL Server ： 理解GAM与SGAM页。 第5个、6个页，（页号4,5），在SQL Server架构里当前没有被使用。页类型是0。如果用DBCC PAGE命令查看这些页只会输出页头信息，并以非法页类型结束。 第7个页，页号6，是第一个DCM页（page type 16）。SQL Server使用DCM页来跟踪自上次完整备份后，修改过的区信息。每个区对应DCM页里的一个位。如果这个位的值1，对应区自上一次完整备份后，已被修改。如果这个位值是0，对应区自上一次完整备份后，未作修改。一个DCM页可以保存接近64000个区的信息。每511232个页，DCM页会重复一个。一个DCM页可以跟踪63904个区信息。第2个DCM页出现在第511238页。SQL Server： 理解DCM页。 第8个页，页号7，是第一个BCM页（page type 17）。SQL Server使用BCM页来跟踪自上次日志备份后，通过大容量日志操作被修改的区信息。每个区对应BCM页里一个位。如果这个位的值是1，对应区自上一次日志备份后，因大容量日志操作后，这个区被修改。如果这个位的值是0，对应区自上一次日志备份后，因大容量日志操作后，这个区未被修改。一个BCM页可以保存近64000个区的信息。每511232个页，BCM页会重复一个。一个BCM页可以跟踪63904个区信息。第2个BCM页出现在第511239页。SQL Server ：理解BCM页。 第9个页，页号8，是第一个IAM页（page type 10）。IAM页是用来跟踪，指定表的分配单元的对应页或区在GAM内的分区里的分配情况。SQL Server ：理解IAM页。 第10个页，页号9，是启动页（page type 13）。启动页只出现在主数据文件（prmary data file）里的第9页，启动页不会出现在第2个数据文件里。我们可以使用DBCC PAGE命令查看它的页信息，在这个页里保存的页信息值是自说明的。如果这个页因某些原因损坏的话，我们将不能使用命令DBCC CheckDb来修复。页还原也不能改变这个情况。只能从上一次好的数据库备份中恢复才可以修复这个问题。 从第11页开始，你可以看到各种不同的页混合在一起，像数据页，索引页，IAM页，行溢出页和LOB页等等。数据页的页类型是1，索引页的页类型是2，行溢出（Row-overflow）页和LOB页的页类型是3。数据页和索引页是以同样结构保存的。SQL Server：理解数据页结构。 行溢出（Row-overflow）页用来存储不能在一页里保存的数据。LOB页用来保存大型对象，并不作为行数据的一部分来保存。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[01.SQL SERVER如何执行一个查询]]></title>
      <url>%2F2017%2F03%2F01%2Fhow-sql-server-executes-a-query%2F</url>
      <content type="text"><![CDATA[根据SQLpassion推送的 SQLpassion Performance Tuning Training Plan - Week 1: How SQL Server executes a Query。记录一下对查询执行的了解。 提交查询客户端提交给数据库的查询通过SQL Server网络接口等协议层(Protocol Layer)传给命令解析器。 命令解析器(Command Parser)处理命令解释器接收到查询会做以下工作： 检查 语法正确 数据库表存在 查询列存在 生成查询树(Query Tree)：重现查询 查询树提交给查询优化器 查询优化器(Query Optimizer)处理 查询优化器将查询树编译为查询计划(Execution Plan) 将查询计划缓存到缓冲池(Buffer Pool)中的执行计划缓存区(Plan Cache) 将查询计划提交给查询执行器 查询执行器(Query Executor)处理 查询分析器根据查询计划向存取方法(Access Methods)拿指定的读取页,存取方法会向缓冲区管理器读取想要指定页。 缓存区管理器(Buffer Manager)检查它是否已在数据缓存(data cache)，如果没找到的话就从磁盘加载到缓存。 当请求的页面已经被存在缓冲池时,页会被立即读取,称为逻辑读。 如果请求的页没存在缓冲池,缓冲区管理器会发起异步I/O操作把请求的页存储子系统中读到缓冲池,称为物理读。修改数据 当修改数据(INSERT,DELETE,UPDATE)时，需要与事务管理器进行交互，事务管理器把执行事务中描述的改变通过事务日志写到事务文件。 数据缓存(Data Cache)查看每个数据库占用了多大数据缓存(sys.dm_os_buffer_descriptors) 12345678SELECT count(*)*8/1024 AS 'Cached Size (MB)' ,CASE database_id WHEN 32767 THEN 'ResourceDb' ELSE db_name(database_id) END AS 'Database'FROM sys.dm_os_buffer_descriptorsGROUP BY db_name(database_id),database_idORDER BY 'Cached Size (MB)' DESC 干净页和脏页清除干净页 1DBCC DROPCLEANBUFFERS 查询脏页 12345SELECT db_name(database_id) AS 'Database',count(page_id) AS 'Dirty Pages'FROM sys.dm_os_buffer_descriptorsWHERE is_modified =1GROUP BY db_name(database_id)ORDER BY count(page_id) DESC 参考文献understanding-how-sql-server-executes-a-query第1/24周 SQL Server 如何执行一个查询SQL Server 2012：SQL Server体系结构——一个查询的生命周期(1)SQL Server 2012：SQL Server体系结构——一个查询的生命周期(2)SQL Server 2012：SQL Server体系结构——一个查询的生命周期(3)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于备案后续]]></title>
      <url>%2F2017%2F03%2F01%2Fabout-beian-2%2F</url>
      <content type="text"><![CDATA[通过腾讯云备案，腾讯初审大约用了2天（包括提交资料和照片），然后昨天（2017年2月28日 中午12:43）腾讯正式把备案材料提交给管局审核，今天（2017年3月1日 上午10:43）就收到了审核通过的邮件和短信。真可谓快。出乎了我的想象。因为是个人备案，步骤很简单，一部手机+身份证就可以了。据说需要居住证的，也能没有要求提交，可能是放宽了政策吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于备案]]></title>
      <url>%2F2017%2F02%2F24%2Fabout-Beian%2F</url>
      <content type="text"><![CDATA[为了规范互联网信息服务活动，促进互联网信息服务健康有序发展，根据国务院令第292号《互联网信息服务管理办法》和工信部令第33号《非经营性互联网信息服务备案管理办法》规定，国家对经营性互联网信息服务实行许可制度，对非经营性互联网信息服务实行备案制度。未取得许可或者未履行备案手续的，不得从事互联网信息服务，否则就属于违法行为。 因此按照规定，需要对自己的网站进行备案。以防后面无法使用的情况发生。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Nginx运行网站]]></title>
      <url>%2F2017%2F02%2F24%2Fserver-with-nginx%2F</url>
      <content type="text"><![CDATA[hexo server 不太好用，决定使用nginx。 首先在服务器上安装nginx，以ubuntu为例。使用apt-get安装比较方便，节省很多配置。 1sudo apt-get nginx 然后开始配置nginx： 123cd /etc/nginxsudp cp /etc/nginx/nginx.conf /etc/nginx/nginx.conf.baksudo vi /etc/nginx/nginx.conf 配置内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141user www-data;worker_processes auto;pid /run/nginx.pid;events &#123; worker_connections 768; # multi_accept on;&#125;http &#123; ## # Basic Settings ## sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; # server_tokens off; # server_names_hash_bucket_size 64; # server_name_in_redirect off; include /etc/nginx/mime.types; default_type application/octet-stream; ## # SSL Settings ## ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE ssl_prefer_server_ciphers on; ## # Logging Settings ## # log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; error_log /var/log/nginx/error.log; ## # Gzip Settings ## gzip on; gzip_disable &quot;msie6&quot;; gzip_min_length 1k; gzip_vary on; gzip_proxied any; gzip_comp_level 6; gzip_buffers 16 8k; gzip_http_version 1.1; gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript; ## # Http Proxy Settings ## client_max_body_size 10m; client_body_buffer_size 128k; proxy_connect_timeout 75; proxy_send_timeout 75; proxy_read_timeout 75; proxy_buffer_size 4k; proxy_buffers 4 32k; proxy_busy_buffers_size 64k; proxy_temp_file_write_size 64k; proxy_temp_path /tmp/proxy_temp 1 2; ## # Upstream Settings ## upstream backend &#123; ip_hash; server 127.0.0.1:4000 max_fails=2 fail_timeout=30s ; # server 192.168.10.101:8080 max_fails=2 fail_timeout=30s ; &#125; ## # Server Settings ## ## Server baochen.name server &#123; listen 80; server_name baochen.name; charset utf-8; access_log /var/log/nginx/baochen.name.access.log; error_log /var/log/nginx/baochen.name.error.log; location / &#123; # proxy_pass http://backend; # proxy_redirect off; # proxy_set_header Host $host; # proxy_set_header X-Real-IP $remote_addr; # proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504; root /var/www/hexoblog; index index.html; &#125; location /nginx_status &#123; stub_status on; access_log /var/log/nginx/ngs.access.log; # allow 192.168.10.0/24; # deny all; &#125; location ~ ^/(WEB-INF)/ &#123; deny all; &#125; # error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; ## # Virtual Host Configs ## include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*;&#125; 编辑完成后 esc -&gt; !wq 退出。 编写crontab脚本: 123456789101112131415#!/bin/bash#this srcipt call by cron #will not exoprt some env var in profile or .profilerm -fr ~/update.log#execute profile. /etc/profile. ~/.profile#auto pull source code , generate and deploy to git. ~/HexoBlog/AutoUpdate.sh &gt;&gt; ~/update.log # 根据实际位置填写#deploysudo cp -r ~/HexoBlog/public/* /var/www/hexoblog # 注意权限 其中 脚本 AutoUpdate.sh 是自己随着库进行同步的 ，内容如下(之所以两个脚本原因看这里)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/bin/bash# 如果使用cron 定时call 更新脚本 # 会出现 一些定义在profile 中的环境变量无法引入的情况# 可以单独建立一个壳脚本 添加一些必要的变量 再呼叫当前脚本 AutoUpdate.sh#. /etc/profile#. ~/.profile#. ~/&lt;somepath&gt;/AutoUpdate.sh # call this srciptDEFAULT_DIR=$HOME/HexoBlogecho &quot;========================================&quot; echo $(date +%y_%m_%d_%H_%I_%T) echo &quot;----------------------------------------&quot; echo &quot;HOME : $HOME&quot;echo &quot;PATH : $PATH&quot;echo &quot;NODE_HOME : $NODE_HOME&quot;echo `whereis hexo`echo &quot;----------------------------------------&quot; if [ $1 ] ; then echo &quot;first argument is not empty : $1&quot; TAR_DIR=$1 echo &quot;use first argument as target dir : $TAR_DIR&quot; else echo &quot;first argument is empty&quot; # use $DEFAULT_DIR as the target dir TAR_DIR=$DEFAULT_DIR echo &quot;use default dir as target dir : $TAR_DIR&quot; fi echo &quot;----------------------------------------&quot; if [ -d $TAR_DIR ] ; then echo &quot;$TAR_DIR is a dir,try update&quot; cd $TAR_DIR echo &quot;++++++++++++++begin git pull++++++++++++&quot; git pull echo &quot;++++++++++++++begin hexo clean+++++++++&quot; hexo clean echo &quot;++++++++++++++begin hexo generate+++++++&quot; hexo g echo &quot;++++++++++++++begin hexo deploy+++++++++&quot; hexo d #echo &quot;++++++++++++++begin killall hexo++++++++&quot; #killall hexo #echo &quot;++++++++++++++begin hexo server+++++++++&quot; #hexo server &amp; else echo &quot;$TAR_DIR is not a dir,do nothing&quot; fiecho &quot;----------------------------------------&quot; echo $(date +%y_%m_%d_%H_%I_%T) echo &quot;========================================&quot; 然后 启动nginx ！ 1sudo service nginx start 完成！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于crontab执行脚本环境变量问题]]></title>
      <url>%2F2017%2F02%2F24%2Fabout-crontab%2F</url>
      <content type="text"><![CDATA[搭建自己的博客配置了自动化脚本，用来同步git仓库、执行hexo命令生成&amp;部署站点。 脚本内容如下 123456789101112131415161718192021222324252627282930313233343536373839404142#!/bin/bashDEFAULT_DIR=$HOME/HexoBlogecho &quot;========================================&quot; echo $(date +%y_%m_%d_%H_%I_%T) echo &quot;----------------------------------------&quot; echo &quot;HOME : $HOME&quot;echo &quot;PATH : $PATH&quot;echo &quot;NODE_HOME : $NODE_HOME&quot;echo `whereis hexo`echo &quot;----------------------------------------&quot; if [ $1 ] ; then echo &quot;first argument is not empty : $1&quot; TAR_DIR=$1 echo &quot;use first argument as target dir : $TAR_DIR&quot; else echo &quot;first argument is empty&quot; # use $DEFAULT_DIR as the target dir TAR_DIR=$DEFAULT_DIR echo &quot;use default dir as target dir : $TAR_DIR&quot; fi echo &quot;----------------------------------------&quot; if [ -d $TAR_DIR ] ; then echo &quot;$TAR_DIR is a dir,try update&quot; cd $TAR_DIR echo &quot;++++++++++++++begin git pull++++++++++++&quot; git pull echo &quot;++++++++++++++begin hexo clean+++++++++&quot; hexo clean echo &quot;++++++++++++++begin hexo generate+++++++&quot; hexo g echo &quot;++++++++++++++begin hexo deploy+++++++++&quot; hexo d echo &quot;++++++++++++++begin killall hexo++++++++&quot; killall hexo echo &quot;++++++++++++++begin hexo server+++++++++&quot; hexo server &amp; else echo &quot;$TAR_DIR is not a dir,do nothing&quot; fiecho &quot;----------------------------------------&quot; echo $(date +%y_%m_%d_%H_%I_%T) echo &quot;========================================&quot; 脚本中使用了nodejs中的hexo，在登录状态下，运行命令行是正常的。 这是由于在 /etc/profile 中配置了环境变量 ，添加了 NODE_HOME 、NODE_PATH 并将 NODE_HOME/bin 添加到 PATH。这样，安装的 nodejs 包（默认安装的NODE_HOME/lib/node_modules，使用npm安装同时会创建软链接到 NODE_HOME/bin）都可以直接访问到。 1234#set nodejs env export NODE_HOME=/usr/local/node export PATH=$NODE_HOME/bin:$PATH export NODE_PATH=$NODE_HOME/lib/node_modules:$PATH 但是问题在于，crontab 执行脚本时。没有用户登录（用户登录会执行 /etc/profile 和 ~/.profile）以及打开终端（打开终端会执行 /etc/bashrc 和 ~/.bashrc）的动作，需要的诸如 NODE_HOME 、NODE_PATH 等（通过/etc/profile 导入）就找不到了，PATH中也没有node的路径。 因此，这种情况下，配置 crontab 如下: 110 * * * * $HOME/CallAutoUpdate.sh # 每十分钟执行一次 其中CallAutoUpdate.sh为： 12345678#!/bin/bash# this srcipt call by cron # will not exoprt some env var in profile or .profile# so ...rm -fr ~/update.log. /etc/profile. ~/.profile. ~/HexoBlog/AutoUpdate.sh &gt;&gt; ~/update.log 这样就解决了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo搭建个人博客]]></title>
      <url>%2F2017%2F02%2F22%2Ffirst-blog%2F</url>
      <content type="text"><![CDATA[发现一个基于 Node.js的高效的静态站点生成框架Hexo,使用 Markdown 编写文章,于是用来搭建自己的网站。接下来介绍如何一步一步完成搭建的。 目录 准备 构建 创建 配置 主题 插件 写作 生成 运行 部署 准备需要在电脑中安装以下： node.js node 安装后 自带 npm 包管理器。安装方式请参考官网。 git git 用于创建hexo项目、更换主题、管理创建的hexo项目源码以及部署到github.io使用。安装方式请参考官网。 hexo-cli 用于创建、管理、发布hexo项目。使用npm包管理器安装：1npm install -g hexo-cli 构建安装完 node 、git 以及hexo-cli 后，就可以开始构建hexo blog了。 创建在源码目录下，命令行运行 1hexo init youbsitename 就可以创建名为 youbsitename 的站点目录了。此过程会clone一些项目到本地站点目录，过程如下： 1234567891011121314151617181920212223INFO Cloning hexo-starter to D:\Temp\testCloning into &apos;D:\Temp\test&apos;...remote: Counting objects: 53, done.remote: Total 53 (delta 0), reused 0 (delta 0), pack-reused 53Unpacking objects: 100% (53/53), done.Submodule &apos;themes/landscape&apos; (https://github.com/hexojs/hexo-theme-landscape.git) registered for path &apos;themes/landscape&apos;Cloning into &apos;D:/Temp/test/themes/landscape&apos;...remote: Counting objects: 764, done.remote: Compressing objects: 100% (3/3), done.remote: Total 764 (delta 0), reused 0 (delta 0), pack-reused 761Receiving objects: 100% (764/764), 2.53 MiB | 53.00 KiB/s, done.Resolving deltas: 100% (390/390), done.Submodule path &apos;themes/landscape&apos;: checked out &apos;decdc2d9956776cbe95420ae94bac87e22468d38&apos;INFO Install dependenciesnpm WARN deprecated swig@1.4.2: This package is no longer maintainednpm WARN deprecated minimatch@0.3.0: Please update to minimatch 3.0.2 or higher to avoid a RegExp DoS issuenpm WARN prefer global marked@0.3.6 should be installed with -g&gt; dtrace-provider@0.8.0 install D:\Temp\test\node_modules\dtrace-provider&gt; node scripts/install.js&gt; hexo-util@0.6.0 postinstall D:\Temp\test\node_modules\hexo-util&gt; npm run build:highlight&gt; hexo-util@0.6.0 build:highlight D:\Temp\test\node_modules\hexo-util&gt; node scripts/build_highlight_alias.js &gt; highlight_alias.json 然后，进入blog目录，就可以对blog进行操作了。 1cd yousitename &amp;&amp; dir blog 目录结构如下 123456789yousitename├─package.json 项目package├─_config.yml 站点配置文件├─public 发布文件夹├─scaffolds 模版文件夹├─source 原始文件，通过&quot;hexo g&quot;将本目录下的文件生成为html等到public文件夹├─themes 主题文件夹├─...└─... 配置根目录下的站点配置文件 _config.yml 中的内容是对项目的一些配置，例如 网站信息：作者、名称、描述等 网站结构 发布方式：支持发布到git(需要插件hexo-deployer-git支持) 主题修改站点配置文件 _config.yml 中的内容：1theme: next(你想要的主题，主题需要放在站点目录下的themes目录下) 官网有提供主题列表可以选择，当然你也可以做自己的主题 另外，主题也有自己的主题配置文件 _config.yml，存放主题自己的一些配置。主题配置文件位置在主题目录下。 插件同样，hexo提供了插件功能，可以提供很多生成、发布和运行等的功能。例如可以生成静态网站后，通过插件hexo-deployer-git将生成的内容发布到git.利用这个插件搭配github.io,可以实现自动生成&amp;部署自己的网站。 写作1hexo new [layout] &lt;title&gt; Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。如果不想文章被布局处理，可以将 Front-Matter 中的layout: 设为 false 。 布局 路径 post source/_posts page source draft source/_drafts 更多的写作可以参考官网. 建议创建页面 : tags 和categories 页面,生成的时候可以自动生成分类)和标签页面的内容。 12hexo new page tagshexo new page categories 生成1hexo generate 或者 1hexo g 默认将静态网站生成到 public 目录下，生成完成后就可以将 public 目录下的内容发布到静态网站服务器上。 运行可以使用 hexo server 命令，本地启动服务器，运行网站 1hexo server 默认启动端口为 4000 的服务端，可以使用 http://localhost:4000 访问。 部署代码托管将创建的网站仓库托管到github，注册等过程不表。 配置自己的网站仓库，然后就可以git commit &amp; git push ,将源码推送到github上。这样就可以随时编辑自己的网站了。 不必要的内容不需要提交，可以使用 .gitignore， 贴一下自己的 .gitignore 文件: 1234567891011121314151617181920212223242526272829303132333435363738394041424344# Logslogs*.lognpm-debug.log*# Runtime datapids*.pid*.seed# Directory for instrumented libs generated by jscoverage/JSCoverlib-cov# Coverage directory used by tools like istanbulcoverage# nyc test coverage.nyc_output# Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files).grunt# node-waf configuration.lock-wscript# Compiled binary addons (http://nodejs.org/api/addons.html)build/Release# Dependency directoriesnode_modulesjspm_packages# Optional npm cache directory.npm# Optional REPL history.node_repl_history.DS_StoreThumbs.dbdb.json*.logpublic/.deploy*/ 自动部署云服务器在云服务器(ubuntu 16.04)上安装 nodejs 、git 、hexo-cli 然后clone 到仓库本地： 12cd ~ git clone https://github.com/dp9u0/HexoBlog 创建周期执行的呼叫脚本： 1vi CallHexoBlogAutoUpdate.sh CallHexoBlogAutoUpdate.sh脚本中，添加以下内容，呼叫仓库中的自动更新脚本： 12#!/bin/bash. ~/HexoBlog/AutoUpdate.sh 为什么要有两个脚本: CallHexoBlogAutoUpdate.sh 和 AutoUpdate.sh?不知道怎么给 AutoUpdate.sh 添加权限 ，不同的操作系统clone后，权限依旧保留。同时 . ~/HexoBlog/AutoUpdate.sh 如果直接配置在 crontab 环境变量好像有点问题。因此将所以自动更新的逻辑放在 AutoUpdate.sh 并且在每个需要执行自动更新的机器上添加外壳程序 CallHexoBlogAutoUpdate.sh 用点符号执行脚本 AutoUpdate.sh。并且外壳程序添加到定时任务中。 调用的自动更新脚本（该脚本加入到git仓库中，可以自更新）： 1234567891011121314151617181920212223242526272829303132333435363738#!/bin/bashLOG_FILE=~/HexoBlogAutoUpdate.logecho &quot;========================================&quot; &gt;&gt; $LOG_FILEecho $(date +%y_%m_%d_%H_%I_%T) &gt;&gt; $LOG_FILEecho &quot;----------------------------------------&quot; &gt;&gt; $LOG_FILEif [ $1 ] ; then echo &quot;first argument is not empty : $1&quot; &gt;&gt; $LOG_FILE TAR_DIR=$1 echo &quot;use first argument as target dir : $TAR_DIR&quot; &gt;&gt; $LOG_FILEelse echo &quot;first argument is empty&quot; &gt;&gt; $LOG_FILE # use ~/HexoBlog as the default dir TAR_DIR=~/HexoBlog # 修改为你需要的默认路径 echo &quot;use default dir as target dir : $TAR_DIR&quot; &gt;&gt; $LOG_FILEfi echo &quot;----------------------------------------&quot; &gt;&gt; $LOG_FILEif [ -d $TAR_DIR ] ; then echo &quot;$TAR_DIR is a dir,try update&quot; &gt;&gt; $LOG_FILE cd $TAR_DIR echo &quot;++++++++++++++++++++++++++++++++++++++++&quot; &gt;&gt; $LOG_FILE git pull &gt;&gt; $LOG_FILE # 同步git echo &quot;++++++++++++++++++++++++++++++++++++++++&quot; &gt;&gt; $LOG_FILE killall hexo &gt;&gt; $LOG_FILE # 关闭 hexo server echo &quot;++++++++++++++++++++++++++++++++++++++++&quot; &gt;&gt; $LOG_FILE hexo clean &gt;&gt; $LOG_FILE # 清理 echo &quot;++++++++++++++++++++++++++++++++++++++++&quot; &gt;&gt; $LOG_FILE hexo g &gt;&gt; $LOG_FILE # 生成 echo &quot;++++++++++++++++++++++++++++++++++++++++&quot; &gt;&gt; $LOG_FILE hexo server &amp; # 启动 hexo server echo &quot;++++++++++++++++++++++++++++++++++++++++&quot; &gt;&gt; $LOG_FILE hexo d &gt;&gt; $LOG_FILE # 自动 echo &quot;++++++++++++++++++++++++++++++++++++++++&quot; &gt;&gt; $LOG_FILEelse echo &quot;$TAR_DIR is not a dir,do nothing&quot; &gt;&gt; $LOG_FILEfiecho &quot;----------------------------------------&quot; &gt;&gt; $LOG_FILEecho $(date +%y_%m_%d_%H_%I_%T) &gt;&gt; $LOG_FILEecho &quot;========================================&quot; &gt;&gt; $LOG_FILE 添加 CallHexoBlogAutoUpdate 脚本执行权限： 1chmod +x CallHexoBlogAutoUpdate.sh 添加定时任务 1crontab -e 添加如下内容 1*/5 * * * * ~/CallHexoBlogAutoUpdate.sh # 五分钟执行检查一次更新 github.iohexo deploy 命令根据站点配置文件_config.yml中的配置，将生成的内容发布到站点中。 其中不同的type需要特殊的插件支持。例如发布到git上，需要插件hexo-deployer-git 首先创建自己的github.io仓库 关于github.io:如果建立了 用户名.github.io 的仓库，github会定时将这个仓库的静态页面发布到 用户名.github.io 的站点上.可以了解更多关于 github.io的内容 站点配置文件配置参考如下： 1234deploy: type: git repo: git@github.com:dp9u0/dp9u0.github.io.git branch: master 部署到git，需要有你的github仓库的push权限，可以参考github文档中关于生成 SSH Key以及添加SSH Key的部分，配置通过SSH免密码push代码到github。 然后，就可以运行生成部署命令了。 12hexo ghexo d 这些也可以添加到AutoUpdate.sh脚本中，这样我只需要在自己的个人电脑上hexo new ,编辑自己的网站，然后git commit 提交，再执行git push到推送到 将源码推送到github上。这样就可以随时编辑自己的网站了。部署在云服务器上的网站 和github.io 上的内容，都会自动更新了！]]></content>
    </entry>

    
  
  
</search>
