<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>关于备案</title>
    <url>/2017/02/24/about-Beian/</url>
    <content><![CDATA[<blockquote class="blockquote-center"><p>为了规范互联网信息服务活动，促进互联网信息服务健康有序发展，根据国务院令第292号《互联网信息服务管理办法》和工信部令第33号《非经营性互联网信息服务备案管理办法》规定，国家对经营性互联网信息服务实行许可制度，对非经营性互联网信息服务实行备案制度。未取得许可或者未履行备案手续的，不得从事互联网信息服务，否则就属于违法行为。</p>
</blockquote>

<a id="more"></a>

<p>因此按照规定，需要对自己的网站进行备案。以防后面无法使用的情况发生。</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>beian</tag>
      </tags>
  </entry>
  <entry>
    <title>关于备案后续</title>
    <url>/2017/03/01/about-beian-2/</url>
    <content><![CDATA[<p>通过腾讯云备案，腾讯初审大约用了2天（包括提交资料和照片），然后昨天（2017年2月28日 中午12:43）腾讯正式把备案材料提交给管局审核，今天（2017年3月1日 上午10:43）就收到了审核通过的邮件和短信。<br>真可谓快。出乎了我的想象。<br>因为是个人备案，步骤很简单，一部手机+身份证就可以了。<br>据说需要居住证的，也能没有要求提交，可能是放宽了政策吧。</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>beian</tag>
      </tags>
  </entry>
  <entry>
    <title>关于crontab执行脚本环境变量问题</title>
    <url>/2017/02/24/about-crontab/</url>
    <content><![CDATA[<p>搭建自己的博客配置了自动化脚本，用来同步git仓库、执行hexo命令生成&amp;部署站点。</p>
<a id="more"></a>

<p>脚本内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">DEFAULT_DIR&#x3D;$HOME&#x2F;HexoBlog</span><br><span class="line">echo &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; </span><br><span class="line">echo $(date +%y_%m_%d_%H_%I_%T) </span><br><span class="line">echo &quot;----------------------------------------&quot; </span><br><span class="line">echo &quot;HOME : $HOME&quot;</span><br><span class="line">echo &quot;PATH : $PATH&quot;</span><br><span class="line">echo &quot;NODE_HOME : $NODE_HOME&quot;</span><br><span class="line">echo &#96;whereis hexo&#96;</span><br><span class="line">echo &quot;----------------------------------------&quot; </span><br><span class="line">if [ $1 ] ; then        </span><br><span class="line">    echo &quot;first argument is not empty : $1&quot; </span><br><span class="line">    TAR_DIR&#x3D;$1 </span><br><span class="line">    echo &quot;use first argument as target dir : $TAR_DIR&quot; </span><br><span class="line">else</span><br><span class="line">    echo &quot;first argument is empty&quot;   </span><br><span class="line">    # use $DEFAULT_DIR as the target dir    </span><br><span class="line">    TAR_DIR&#x3D;$DEFAULT_DIR</span><br><span class="line">    echo &quot;use default dir as target dir : $TAR_DIR&quot; </span><br><span class="line">fi </span><br><span class="line">echo &quot;----------------------------------------&quot; </span><br><span class="line">if [ -d $TAR_DIR ] ; then </span><br><span class="line">    echo &quot;$TAR_DIR is a dir,try update&quot; </span><br><span class="line">    cd $TAR_DIR</span><br><span class="line">    echo &quot;++++++++++++++begin git pull++++++++++++&quot; </span><br><span class="line">    git pull </span><br><span class="line">    echo &quot;++++++++++++++begin  hexo clean+++++++++&quot;</span><br><span class="line">    hexo clean </span><br><span class="line">    echo &quot;++++++++++++++begin  hexo generate+++++++&quot;</span><br><span class="line">    hexo g </span><br><span class="line">    echo &quot;++++++++++++++begin hexo deploy+++++++++&quot;</span><br><span class="line">    hexo d </span><br><span class="line">    echo &quot;++++++++++++++begin killall hexo++++++++&quot; </span><br><span class="line">    killall hexo </span><br><span class="line">    echo &quot;++++++++++++++begin hexo server+++++++++&quot;</span><br><span class="line">    hexo server &amp;   </span><br><span class="line">else</span><br><span class="line">    echo &quot;$TAR_DIR is not a dir,do nothing&quot; </span><br><span class="line">fi</span><br><span class="line">echo &quot;----------------------------------------&quot; </span><br><span class="line">echo $(date +%y_%m_%d_%H_%I_%T) </span><br><span class="line">echo &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;</span><br></pre></td></tr></table></figure>
<p>脚本中使用了nodejs中的hexo，在登录状态下，运行命令行是正常的。</p>
<p>这是由于在 /etc/profile 中配置了环境变量 ，添加了 NODE_HOME 、NODE_PATH 并将 NODE_HOME/bin 添加到 PATH。<br>这样，安装的 nodejs 包（默认安装的NODE_HOME/lib/node_modules，使用npm安装同时会创建软链接到 NODE_HOME/bin）都可以直接访问到。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#set nodejs env  </span><br><span class="line">export NODE_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;node  </span><br><span class="line">export PATH&#x3D;$NODE_HOME&#x2F;bin:$PATH  </span><br><span class="line">export NODE_PATH&#x3D;$NODE_HOME&#x2F;lib&#x2F;node_modules:$PATH</span><br></pre></td></tr></table></figure>

<p>但是问题在于，crontab 执行脚本时。没有用户登录（用户登录会执行 /etc/profile 和 ~/.profile）<br>以及打开终端（打开终端会执行 /etc/bashrc 和 ~/.bashrc）的动作，需要的诸如 NODE_HOME 、NODE_PATH 等（通过/etc/profile 导入）就找不到了，PATH中也没有node的路径。</p>
<p>因此，这种情况下，配置 crontab 如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 * * * * $HOME&#x2F;CallAutoUpdate.sh # 每十分钟执行一次</span><br></pre></td></tr></table></figure>

<p>其中CallAutoUpdate.sh为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"># this srcipt call by cron </span><br><span class="line"># will not exoprt some env var in profile or .profile</span><br><span class="line"># so ...</span><br><span class="line">rm -fr ~&#x2F;update.log</span><br><span class="line">. &#x2F;etc&#x2F;profile</span><br><span class="line">. ~&#x2F;.profile</span><br><span class="line">. ~&#x2F;HexoBlog&#x2F;AutoUpdate.sh &gt;&gt; ~&#x2F;update.log</span><br></pre></td></tr></table></figure>

<p>这样就解决了。</p>
]]></content>
      <categories>
        <category>knowledge</category>
      </categories>
      <tags>
        <tag>crontab</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>02.SQL Server存储单位:页(Page)</title>
    <url>/2017/03/01/data-pages-the-foundation-of-sql-server/</url>
    <content><![CDATA[<p>SQL Server 基本存储单位是页，一个页大小为8K。<br>页分为不同的类型：</p>
<a id="more"></a>

<p>1 Data page 堆表和聚集索引的叶子节点数据<br>2 Index page    聚集索引的非叶子节点和非聚集索引的所有索引记录<br>3 Text mixed page    A text page that holds small chunks of LOB values plus internal parts of text tree. These can be shared between LOB values in the same partition of an index or heap.<br>4 Text tree page    A text page that holds large chunks of LOB values from a single column value.<br>7 Sort page    排序时所用到的临时页，排序中间操作存储数据用的。<br>8 GAM page 全局分配映射（Global Allocation Map，GAM）页面 这些页面记录了哪些区已经被分配并用作何种用途。<br>9 SGAM page    共享全局分配映射（Shared Global Allocation Map，GAM）页面 这些页面记录了哪些区当前被用作混合类型的区，并且这些区需含有至少一个未使用的页面。<br>10 IAM page  有关每个分配单元中表或索引所使用的区的信息<br>11 PFS page  有关页分配和页的可用空间的信息<br>13 boot page 记录了关于数据库的信息，仅存于每个数据库的第9页<br>15 file header page 记录了关于数据库文件的信息，存于每个数据库文件的第0页<br>16 DCM page    记录自从上次全备以来的数据改变的页面，以备差异备份<br>17 BCM page 有关每个分配单元中自最后一条 BACKUP LOG 语句之后的大容量操作所修改的区的信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USE</span> [<span class="keyword">Test</span>]</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">exists</span> (<span class="keyword">select</span> * <span class="keyword">from</span> sysobjects <span class="keyword">where</span> <span class="keyword">id</span> =  object_id(N<span class="string">'[dbo].[Customers]'</span>) <span class="keyword">and</span> OBJECTPROPERTY(<span class="keyword">id</span>, N<span class="string">'IsUserTable'</span>) = <span class="number">1</span> )</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> dbo.Customers</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Customers</span><br><span class="line">(</span><br><span class="line">   FirstName <span class="built_in">CHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">   LastName <span class="built_in">CHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">   Address <span class="built_in">CHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">   ZipCode <span class="built_in">CHAR</span>(<span class="number">5</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">   Rating <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">   ModifiedDate DATETIME <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dbo.Customers</span><br><span class="line">        ( FirstName ,</span><br><span class="line">          LastName ,</span><br><span class="line">          Address ,</span><br><span class="line">          ZipCode ,</span><br><span class="line">          Rating ,</span><br><span class="line">          ModifiedDate</span><br><span class="line">        )</span><br><span class="line"><span class="keyword">VALUES</span>  ( <span class="string">'Philip'</span> , </span><br><span class="line">          <span class="string">'Aschenbrenner'</span> ,</span><br><span class="line">          <span class="string">'Pichlagasse 16/6'</span> , </span><br><span class="line">          <span class="string">'1220'</span> , </span><br><span class="line">          <span class="number">1</span> ,</span><br><span class="line">          <span class="string">'2015-03-25 02:22:51'</span> </span><br><span class="line">        )</span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure>  

<p>DBCC IND 命令用于查询一个存储对象的内部存储结构信息，该命令有4个参数, 前3个参数必须指定。语法如下：<br>DBCC IND ( { ‘dbname’ | dbid }, { ‘objname’ | objid },{ nonclustered indid | 1 | 0 | -1 | -2 } [, partition_number] )<br>第一个参数是数据库名或数据库ID。<br>第二个参数是数据库中的对象名或对象ID，对象可以是表或者索引视图。<br>第三个参数是一个非聚集索引ID或者 1, 0, 1, or 2. 值的含义：<br> 0: 只显示对象的in-row data页和 in-row IAM 页。<br> 1: 显示对象的全部页, 包含IAM 页, in-row数据页, LOB 数据页row-overflow 数据页 . 如果请求的对象含有聚集所以则索引页也包括。<br> -1: 显示全部IAM页,数据页, 索引页 也包括 LOB 和row-overflow 数据页。<br> -2: 显示全部IAM页。<br> Nonclustered index ID:显示索引的全部 IAM页, data页和索引页，包含LOB和 row-overflow数据页。<br>为了兼容sql server 2000,第四个参数是可选的,该参数用于指定一个分区号.如果不给定值或者给定0, 则显示全部分区数据。<br>和DBCC PAGE不同的是, SQL Server运行DBCC IND不需要开启3604跟踪标志.<br>结果中 Page type: 1 = data page, 2 = index page, 3 = LOB_MIXED_PAGE, 4 = LOB_TREE_PAGE, 10 = IAM page   </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DBCC IND('InternalStorageFormat','Customers',-1)</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<table>
<thead>
<tr>
<th align="center">PageFID</th>
<th align="center">PagePID</th>
<th align="center">IAMFID</th>
<th align="center">IAMPID</th>
<th align="center">ObjectID</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">150</td>
<td align="center">NULL</td>
<td align="center">NULL</td>
<td align="center">261575970</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">147</td>
<td align="center">1</td>
<td align="center">150</td>
<td align="center">261575970</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">IndexID</th>
<th align="center">PartitionNumber</th>
<th align="center">PartitionID</th>
<th align="center">iam_chain_type</th>
<th align="center">PageType</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">72057594040614912</td>
<td align="center">In-row data</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">72057594040614912</td>
<td align="center">In-row data</td>
<td align="center">1</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">IndexLevel</th>
<th align="center">NextPageFID</th>
<th align="center">NextPagePID</th>
<th align="center">PrevPageFID</th>
<th align="center">PrevPagePID</th>
</tr>
</thead>
<tbody><tr>
<td align="center">NULL</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>DBCC Page 命令读取数据页结构的命令DBCC Page。<br>该命令为非文档化的命令，具体如下：<br>　　DBCC Page ({dbid|dbname},filenum,pagenum[,printopt])<br>　　具体参数描述如下：<br>　　dbid 包含页面的数据库ID<br>　　dbname 包含页面的数据库的名称<br>　　filenum 包含页面的文件编号<br>　　pagenum 文件内的页面<br>　　printopt 可选的输出选项;选用其中一个值：<br>　　0:默认值，输出缓冲区的标题和页面标题<br>　　1:输出缓冲区的标题、页面标题(分别输出每一行)，以及行偏移量表<br>　　2:输出缓冲区的标题、页面标题(整体输出页面)，以及行偏移量表<br>　　3:输出缓冲区的标题、页面标题(分别输出每一行)，以及行偏移量表;每一行后跟分别列出的它的列值<br>　　要想看到这些输出的结果，还需要设置DBCC TRACEON(3604)。<br>可以使用 WITH TABLERESULTS 显示成表格化的数据形式</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DBCC TRACEON(3604)</span><br><span class="line">DBCC PAGE(InternalStorageFormat,1,41,1) </span><br><span class="line">GO    </span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DBCC 执行完毕。如果 DBCC 输出了错误信息，请与系统管理员联系。</span><br><span class="line">PAGE: (1:147)</span><br><span class="line"></span><br><span class="line">BUFFER:</span><br><span class="line">BUF @0x00000001FEEBDEC0</span><br><span class="line">bpage = 0x0000000184E2E000          bhash = 0x0000000000000000          bpageno = (1:147)</span><br><span class="line">bdbid = 16                          breferences = 0                     bcputicks = 0</span><br><span class="line">bsampleCount = 0                    bUse1 = 36342                       bstat = 0xb</span><br><span class="line">blog = 0x215acccc                   bnext = 0x0000000000000000     </span><br><span class="line"></span><br><span class="line">PAGE HEADER:</span><br><span class="line">Page @0x0000000184E2E000</span><br><span class="line">m_pageId = (1:147)                  m_headerVersion = 1                 m_type = 1</span><br><span class="line">m_typeFlagBits = 0x0                m_level = 0                         m_flagBits = 0x8000</span><br><span class="line">m_objId (AllocUnitId.idObj) = 121   m_indexId (AllocUnitId.idInd) = 256 </span><br><span class="line">Metadata: AllocUnitId = 72057594045857792                                </span><br><span class="line">Metadata: PartitionId = 72057594040614912                                Metadata: IndexId = 0</span><br><span class="line">Metadata: ObjectId = 261575970      m_prevPage = (0:0)                  m_nextPage = (0:0)</span><br><span class="line">pminlen = 221                       m_slotCnt = 1                       m_freeCnt = 7870</span><br><span class="line">m_freeData = 320                    m_reservedCnt = 0                   m_lsn = (34:364:23)</span><br><span class="line">m_xactReserved = 0                  m_xdesId = (0:0)                    m_ghostRecCnt = 0</span><br><span class="line">m_tornBits = 0                      DB Frag ID = 1                      </span><br><span class="line"></span><br><span class="line">Allocation Status</span><br><span class="line">GAM (1:2) = ALLOCATED               SGAM (1:3) = ALLOCATED              </span><br><span class="line">PFS (1:1) = 0x61 MIXED_EXT ALLOCATED  50_PCT_FULL                        DIFF (1:6) = CHANGED</span><br><span class="line">ML (1:7) = NOT MIN_LOGGED           </span><br><span class="line"></span><br><span class="line">Slot 0 Offset 0x60 Length 224</span><br><span class="line">Record Type = PRIMARY_RECORD        Record Attributes =  NULL_BITMAP    Record Size = 224</span><br><span class="line">Memory Dump @0x0000000011C7A060</span><br><span class="line">0000000000000000:   1000dd00 576f6f64 79202020 20202020 20202020  ....Woody           </span><br><span class="line">0000000000000014:   20202020 20202020 20202020 20202020 20202020                      </span><br><span class="line">0000000000000028:   20202020 20202020 20202020 20205475 20202020                Tu    </span><br><span class="line">000000000000003C:   20202020 20202020 20202020 20202020 20202020                      </span><br><span class="line">0000000000000050:   20202020 20202020 20202020 20202020 20202020                      </span><br><span class="line">0000000000000064:   20202020 5a554f51 49414f20 594f5558 4920544f      ZUOQIAO YOUXI TO</span><br><span class="line">0000000000000078:   574e204c 494e4841 49204349 54592020 20202020  WN LINHAI CITY      </span><br><span class="line">000000000000008C:   20202020 20202020 20202020 20202020 20202020                      </span><br><span class="line">00000000000000A0:   20202020 20202020 20202020 20202020 20202020                      </span><br><span class="line">00000000000000B4:   20202020 20202020 20202020 20202020 20202020                      </span><br><span class="line">00000000000000C8:   20202020 30303030 20010000 001480a7 0091a400      0000 ...........</span><br><span class="line">00000000000000DC:   00060000                                      ....   </span><br><span class="line">Slot 0 Column 1 Offset 0x4 Length 50 Length (physical) 50</span><br><span class="line">FirstName = Woody</span><br><span class="line">Slot 0 Column 2 Offset 0x36 Length 50 Length (physical) 50</span><br><span class="line">LastName = Tu </span><br><span class="line">Slot 0 Column 3 Offset 0x68 Length 100 Length (physical) 100</span><br><span class="line">Address = ZUOQIAO YOUXI TOWN LINHAI CITY  </span><br><span class="line">Slot 0 Column 4 Offset 0xcc Length 5 Length (physical) 5</span><br><span class="line">ZipCode = 0000 </span><br><span class="line">Slot 0 Column 5 Offset 0xd1 Length 4 Length (physical) 4</span><br><span class="line">Rating = 1   </span><br><span class="line">Slot 0 Column 6 Offset 0xd5 Length 8 Length (physical) 8</span><br><span class="line">ModifiedDate = 2015-05-07 10:09:51.000  </span><br><span class="line"></span><br><span class="line">OFFSET TABLE:</span><br><span class="line">Row - Offset                        </span><br><span class="line">0 (0x0) - 96 (0x60)  </span><br><span class="line"></span><br><span class="line">DBCC 执行完毕。如果 DBCC 输出了错误信息，请与系统管理员联系。</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>Page @0x08F84000            同BUFFER中的bpage地址<br>m_pageId = (1:79)              数据页号<br>m_headerVersion = 1         头文件版本号，一直为1<br>m_type = 1                          页面类型，1为数据页面<br>m_typeFlagBits = 0x4         数据页和索引页为4，其他页为0<br>m_level = 0                         该页在索引页（B树）中的级数<br>m_flagBits = 0x8000          页面标志<br>m_objId (AllocUnitId.idObj) = 46                       同Metadata: ObjectId<br>m_indexId (AllocUnitId.idInd) = 256                  同Metadata: IndexId<br>Metadata: AllocUnitId = 72057594040942592  存储单元的ID,sys.allocation_units.allocation_unit_id<br>Metadata: PartitionId = 72057594039304192   数据页所在的分区号，sys.partitions.partition_id<br>Metadata: IndexId = 0                                        页面的索引号，sys.objects.object_id&amp;sys.indexes.index_id<br>Metadata: ObjectId = 277576027                      该页面所属的对象的id，sys.objects.object_id<br>m_prevPage = (0:0)                  该数据页的前一页面；主要用在数据页、索引页和IAM页<br>m_nextPage = (0:0)                  该数据页的后一页面；主要用在数据页、索引页和IAM页<br>pminlen = 221                          定长数据所占的字节数<br>m_slotCnt = 2                           页面中的数据的行数<br>m_freeCnt = 7644                    页面中剩余的空间<br>m_freeData = 544                    从第一个字节到最后一个字节的空间字节数<br>m_reservedCnt = 0                   活动事务释放的字节数<br>m_lsn = (255:8406:2)                日志记录号<br>m_xactReserved = 0                 最新加入到m_reservedCnt领域的字节数<br>m_xdesId = (0:0)                       添加到m_reservedCnt的最近的事务id<br>m_ghostRecCnt = 0                 幻影数据的行数<br>m_tornBits = 0                         页的校验位或者被由数据库页面保护形式决定分页保护位取代</p>
<p>GAM (1:2) = ALLOCATED                                                   在GAM页上的分配情况<br>SGAM (1:3) = ALLOCATED                                                 在SGAM页上的分配情况<br>PFS (1:1) = 0x61 MIXED_EXT ALLOCATED  50_PCT_FULL 在PFS页上的分配情况，该页为50%满，<br>DIFF (1:6) = CHANGED<br>ML (1:7) = NOT MIN_LOGGED   </p>
<p>查看空间占用情况<br>free_space_in_bytes 表示在指定页面当前有多少空间是可用的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> sys.dm_os_buffer_descriptors</span><br></pre></td></tr></table></figure>

<p>下面这个查询可以告诉你在你的数据库实例里每个数据有多少空间被浪费，可以找出哪个数据库有糟糕的表设计。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">DB_NAME(database_id),</span><br><span class="line"><span class="keyword">SUM</span>(free_space_in_bytes) / <span class="number">1024</span> <span class="keyword">AS</span> <span class="string">'Free_KB'</span></span><br><span class="line"><span class="keyword">FROM</span> sys.dm_os_buffer_descriptors</span><br><span class="line"><span class="keyword">WHERE</span> database_id &lt;&gt; <span class="number">32767</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> database_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">SUM</span>(free_space_in_bytes) <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure>


<img src="/2017/03/01/data-pages-the-foundation-of-sql-server/112056586572951.png" class="" title="SQL文件结构">

<p>第1个页，页号0，是文件头（page type 15）。它保存着文件头信息。每个数据文件只有一个文件头页，而且是第0页的位置。文件头页里保存着数据文件信息，例如文件大小，最小大小，最大大小和文件增长方式等。</p>
<p>第2个页，页号1，是第一个PFS页（page type 11）。PFS页在数据文件里是第2个页（页号1），紧跟在文件头后（页号0）。GAM和SGAM用来跟踪区分配状态，PFS页用来跟踪页分配级别。当分配页面的时候，数据库引擎使用GAM和SGAM来识别有空页的区。一旦数据库引擎找到有空页的区，它使用PFS页来识别区里空页的可用空间量。可用空间只在保存LOB值（ie text/image, varchar(max),nvarchar(max),varbinary(max) ,row overflow data）或堆表页时跟踪。默认情况下，LOB数据保存在一个独立的页，在原页保存一个指向独立页的指针。这些就是数据能够保存的空页。对于索引页，因为数据的保存顺序和索引顺序是一致的，因此没有必用使用到PFS页。PFS页每8088个页重复一个。这就是说第1页，第8088页，第16176页，第24264页……在每个数据文件里都是PFS页。SQL Server： 理解PFS页。</p>
<p>第3个页，页号2，是第一个GAM页（page type 8）。GAM页用来跟踪哪些区被使用。每个区对应GAM页的一个位。如果这个位的值是1，对应区是空、可用的，如果这个位的值是0，对应区是作为统一区或混合区使用。一个GAM页可以保存接近64000个区的信息。那就是说，一个GAM页可以保存（64000 * 8 * 8）/1024 = 4000 MB的信息。简而言之，一个7GB大小的数据文件将有2个GAM页。SQL Server ： 理解GAM与SGAM页。</p>
<p>第4个页，页号3，是第一个SGAM页（page type 9）。SGAM页用来跟踪哪些区正作为混合区使用且至少有一个可用页。每个区对应一个GAM页的有一个位。如果这个位的值是1，对应区作为混合区使用且至少有个可用页，如果这个位值是0，对应区没作为混合区使用或所有页作为混合区使用了。一个SGAM页可以保存接近64000个区的信息。那就是说，一个SGAM页可以保存64000 * 8 * 8  /1024 =4000MB。简而言之，一个7GB大小的数据文件将有2个SGAM页。SQL Server ： 理解GAM与SGAM页。</p>
<p>第5个、6个页，（页号4,5），在SQL Server架构里当前没有被使用。页类型是0。如果用DBCC PAGE命令查看这些页只会输出页头信息，并以非法页类型结束。</p>
<p>第7个页，页号6，是第一个DCM页（page type 16）。SQL Server使用DCM页来跟踪自上次完整备份后，修改过的区信息。每个区对应DCM页里的一个位。如果这个位的值1，对应区自上一次完整备份后，已被修改。如果这个位值是0，对应区自上一次完整备份后，未作修改。一个DCM页可以保存接近64000个区的信息。每511232个页，DCM页会重复一个。一个DCM页可以跟踪63904个区信息。第2个DCM页出现在第511238页。SQL Server： 理解DCM页。</p>
<p>第8个页，页号7，是第一个BCM页（page type 17）。SQL Server使用BCM页来跟踪自上次日志备份后，通过大容量日志操作被修改的区信息。每个区对应BCM页里一个位。如果这个位的值是1，对应区自上一次日志备份后，因大容量日志操作后，这个区被修改。如果这个位的值是0，对应区自上一次日志备份后，因大容量日志操作后，这个区未被修改。一个BCM页可以保存近64000个区的信息。每511232个页，BCM页会重复一个。一个BCM页可以跟踪63904个区信息。第2个BCM页出现在第511239页。SQL Server ：理解BCM页。</p>
<p>第9个页，页号8，是第一个IAM页（page type 10）。IAM页是用来跟踪，指定表的分配单元的对应页或区在GAM内的分区里的分配情况。SQL Server ：理解IAM页。</p>
<p>第10个页，页号9，是启动页（page type 13）。启动页只出现在主数据文件（prmary data file）里的第9页，启动页不会出现在第2个数据文件里。我们可以使用DBCC PAGE命令查看它的页信息，在这个页里保存的页信息值是自说明的。如果这个页因某些原因损坏的话，我们将不能使用命令DBCC CheckDb来修复。页还原也不能改变这个情况。只能从上一次好的数据库备份中恢复才可以修复这个问题。</p>
<p>从第11页开始，你可以看到各种不同的页混合在一起，像数据页，索引页，IAM页，行溢出页和LOB页等等。数据页的页类型是1，索引页的页类型是2，行溢出（Row-overflow）页和LOB页的页类型是3。数据页和索引页是以同样结构保存的。SQL Server：理解数据页结构。</p>
<p>行溢出（Row-overflow）页用来存储不能在一页里保存的数据。LOB页用来保存大型对象，并不作为行数据的一部分来保存。</p>
<p><a href="http://www.cnblogs.com/wcyao/archive/2011/06/28/2092241.html" target="_blank" rel="noopener">存储引擎揭秘</a><br><a href="http://www.cnblogs.com/woodytu/tag/SQL%20Server%20%E5%AD%98%E5%82%A8/" target="_blank" rel="noopener">SQL Server 存储</a></p>
]]></content>
      <categories>
        <category>knowledge</category>
      </categories>
      <tags>
        <tag>mssql</tag>
        <tag>performance tuning</tag>
      </tags>
  </entry>
  <entry>
    <title>01.SQL SERVER如何执行一个查询</title>
    <url>/2017/03/01/how-sql-server-executes-a-query/</url>
    <content><![CDATA[<p>根据SQLpassion推送的 SQLpassion Performance Tuning Training Plan - Week 1: How SQL Server executes a Query。记录一下对查询执行的了解。</p>
<a id="more"></a>

<h1 id="提交查询"><a href="#提交查询" class="headerlink" title="提交查询"></a>提交查询</h1><p>客户端提交给数据库的查询通过SQL Server网络接口等协议层(Protocol Layer)传给命令解析器。</p>
<h1 id="命令解析器-Command-Parser-处理"><a href="#命令解析器-Command-Parser-处理" class="headerlink" title="命令解析器(Command Parser)处理"></a>命令解析器(Command Parser)处理</h1><p>命令解释器接收到查询会做以下工作：</p>
<ul>
<li>检查<ul>
<li>语法正确</li>
<li>数据库表存在</li>
<li>查询列存在</li>
</ul>
</li>
<li>生成查询树(Query Tree)：重现查询</li>
<li>查询树提交给查询优化器</li>
</ul>
<h1 id="查询优化器-Query-Optimizer-处理"><a href="#查询优化器-Query-Optimizer-处理" class="headerlink" title="查询优化器(Query Optimizer)处理"></a>查询优化器(Query Optimizer)处理</h1><ul>
<li>查询优化器将查询树编译为查询计划(Execution Plan)</li>
<li>将查询计划缓存到缓冲池(Buffer Pool)中的执行计划缓存区(Plan Cache)</li>
<li>将查询计划提交给查询执行器</li>
</ul>
<h1 id="查询执行器-Query-Executor-处理"><a href="#查询执行器-Query-Executor-处理" class="headerlink" title="查询执行器(Query Executor)处理"></a>查询执行器(Query Executor)处理</h1><ul>
<li>查询分析器根据查询计划向存取方法(Access Methods)拿指定的读取页,存取方法会向缓冲区管理器读取想要指定页。</li>
<li>缓存区管理器(Buffer Manager)检查它是否已在数据缓存(data cache)，如果没找到的话就从磁盘加载到缓存。<ul>
<li>当请求的页面已经被存在缓冲池时,页会被立即读取,称为逻辑读。</li>
<li>如果请求的页没存在缓冲池,缓冲区管理器会发起异步I/O操作把请求的页存储子系统中读到缓冲池,称为物理读。</li>
</ul>
</li>
</ul>
<h1 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h1><p>当修改数据(INSERT,DELETE,UPDATE)时，需要与事务管理器进行交互，事务管理器把执行事务中描述的改变通过事务日志写到事务文件。</p>
<img src="/2017/03/01/how-sql-server-executes-a-query/mssqlarch.png" class="" title="sql server 核心架构图">


<h1 id="数据缓存-Data-Cache"><a href="#数据缓存-Data-Cache" class="headerlink" title="数据缓存(Data Cache)"></a>数据缓存(Data Cache)</h1><p>查看每个数据库占用了多大数据缓存(sys.dm_os_buffer_descriptors)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span>(*)*<span class="number">8</span>/<span class="number">1024</span> <span class="keyword">AS</span> <span class="string">'Cached Size (MB)'</span></span><br><span class="line">	,<span class="keyword">CASE</span> database_id</span><br><span class="line">		<span class="keyword">WHEN</span> <span class="number">32767</span> <span class="keyword">THEN</span> <span class="string">'ResourceDb'</span></span><br><span class="line">		<span class="keyword">ELSE</span> db_name(database_id)</span><br><span class="line">		<span class="keyword">END</span> <span class="keyword">AS</span> <span class="string">'Database'</span></span><br><span class="line"><span class="keyword">FROM</span> sys.dm_os_buffer_descriptors</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> db_name(database_id),database_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">'Cached Size (MB)'</span> <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<h1 id="干净页和脏页"><a href="#干净页和脏页" class="headerlink" title="干净页和脏页"></a>干净页和脏页</h1><p>清除干净页</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DBCC DROPCLEANBUFFERS</span><br></pre></td></tr></table></figure>

<p>查询脏页</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> db_name(database_id) <span class="keyword">AS</span> <span class="string">'Database'</span>,<span class="keyword">count</span>(page_id) <span class="keyword">AS</span> <span class="string">'Dirty Pages'</span></span><br><span class="line"><span class="keyword">FROM</span> sys.dm_os_buffer_descriptors</span><br><span class="line"><span class="keyword">WHERE</span> is_modified =<span class="number">1</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> db_name(database_id)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">count</span>(page_id) <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="http://rusanu.com/2013/08/01/understanding-how-sql-server-executes-a-query" target="_blank" rel="noopener">understanding-how-sql-server-executes-a-query</a><br><a href="http://www.cnblogs.com/woodytu/p/4465649.html" target="_blank" rel="noopener">第1/24周 SQL Server 如何执行一个查询</a><br><a href="http://www.cnblogs.com/woodytu/p/4471386.html" target="_blank" rel="noopener">SQL Server 2012：SQL Server体系结构——一个查询的生命周期(1)</a><br><a href="http://www.cnblogs.com/woodytu/p/4472315.html" target="_blank" rel="noopener">SQL Server 2012：SQL Server体系结构——一个查询的生命周期(2)</a><br><a href="http://www.cnblogs.com/woodytu/p/4474652.html" target="_blank" rel="noopener">SQL Server 2012：SQL Server体系结构——一个查询的生命周期(3)</a></p>
]]></content>
      <categories>
        <category>knowledge</category>
      </categories>
      <tags>
        <tag>mssql</tag>
        <tag>performance tuning</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo搭建个人博客</title>
    <url>/2017/02/22/first-blog/</url>
    <content><![CDATA[<blockquote class="blockquote-center"><p>发现一个基于 Node.js的高效的静态站点生成框架<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>,使用 Markdown 编写文章,于是用来搭建自己的网站。<br>接下来介绍如何一步一步完成搭建的。</p>
</blockquote>

<a id="more"></a>

<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#准备">准备</a></li>
<li><a href="#构建">构建</a><ul>
<li><a href="#创建">创建</a></li>
<li><a href="#配置">配置</a></li>
<li><a href="#主题">主题</a></li>
<li><a href="#插件">插件</a></li>
<li><a href="#写作">写作</a></li>
<li><a href="#生成">生成</a></li>
<li><a href="#运行">运行</a></li>
<li><a href="#部署">部署</a></li>
</ul>
</li>
</ul>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>需要在电脑中安装以下：</p>
<ul>
<li><a href="https://nodejs.org/en" target="_blank" rel="noopener">node.js</a></li>
</ul>
<p>node 安装后 自带 npm 包管理器。安装方式请参考官网。</p>
<ul>
<li><a href="https://git-scm.com" target="_blank" rel="noopener">git</a></li>
</ul>
<p>git 用于创建hexo项目、更换主题、管理创建的hexo项目源码以及部署到github.io使用。安装方式请参考官网。</p>
<ul>
<li><a href="https://hexo.io/" target="_blank" rel="noopener">hexo-cli</a></li>
</ul>
<p>用于创建、管理、发布hexo项目。使用npm包管理器安装：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h1 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h1><p>安装完 node 、git 以及hexo-cli 后，就可以开始构建hexo blog了。</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>在源码目录下，命令行运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init youbsitename</span><br></pre></td></tr></table></figure>

<p>就可以创建名为 <strong>youbsitename</strong> 的站点目录了。此过程会clone一些项目到本地站点目录，过程如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INFO  Cloning hexo-starter to D:\Temp\test</span><br><span class="line">Cloning into &#39;D:\Temp\test&#39;...</span><br><span class="line">remote: Counting objects: 53, done.</span><br><span class="line">remote: Total 53 (delta 0), reused 0 (delta 0), pack-reused 53</span><br><span class="line">Unpacking objects: 100% (53&#x2F;53), done.</span><br><span class="line">Submodule &#39;themes&#x2F;landscape&#39; (https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexo-theme-landscape.git) registered for path &#39;themes&#x2F;landscape&#39;</span><br><span class="line">Cloning into &#39;D:&#x2F;Temp&#x2F;test&#x2F;themes&#x2F;landscape&#39;...</span><br><span class="line">remote: Counting objects: 764, done.</span><br><span class="line">remote: Compressing objects: 100% (3&#x2F;3), done.</span><br><span class="line">remote: Total 764 (delta 0), reused 0 (delta 0), pack-reused 761</span><br><span class="line">Receiving objects: 100% (764&#x2F;764), 2.53 MiB | 53.00 KiB&#x2F;s, done.</span><br><span class="line">Resolving deltas: 100% (390&#x2F;390), done.</span><br><span class="line">Submodule path &#39;themes&#x2F;landscape&#39;: checked out &#39;decdc2d9956776cbe95420ae94bac87e22468d38&#39;</span><br><span class="line">INFO  Install dependencies</span><br><span class="line">npm WARN deprecated swig@1.4.2: This package is no longer maintained</span><br><span class="line">npm WARN deprecated minimatch@0.3.0: Please update to minimatch 3.0.2 or higher to avoid a RegExp DoS issue</span><br><span class="line">npm WARN prefer global marked@0.3.6 should be installed with -g</span><br><span class="line">&gt; dtrace-provider@0.8.0 install D:\Temp\test\node_modules\dtrace-provider</span><br><span class="line">&gt; node scripts&#x2F;install.js</span><br><span class="line">&gt; hexo-util@0.6.0 postinstall D:\Temp\test\node_modules\hexo-util</span><br><span class="line">&gt; npm run build:highlight</span><br><span class="line">&gt; hexo-util@0.6.0 build:highlight D:\Temp\test\node_modules\hexo-util</span><br><span class="line">&gt; node scripts&#x2F;build_highlight_alias.js &gt; highlight_alias.json</span><br></pre></td></tr></table></figure>
<p>然后，进入blog目录，就可以对blog进行操作了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd yousitename &amp;&amp; dir</span><br></pre></td></tr></table></figure>

<p>blog 目录结构如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yousitename</span><br><span class="line">├─package.json      项目package</span><br><span class="line">├─_config.yml       站点配置文件</span><br><span class="line">├─public            发布文件夹</span><br><span class="line">├─scaffolds         模版文件夹</span><br><span class="line">├─source            原始文件，通过&quot;hexo g&quot;将本目录下的文件生成为html等到public文件夹</span><br><span class="line">├─themes            主题文件夹</span><br><span class="line">├─...</span><br><span class="line">└─...</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>根目录下的站点配置文件 _config.yml 中的内容是对项目的一些配置，例如</p>
<ul>
<li>网站信息：作者、名称、描述等</li>
<li>网站结构</li>
<li>发布方式：支持发布到git(需要插件<a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a>支持)</li>
</ul>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>修改站点配置文件 _config.yml 中的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: next(你想要的主题，主题需要放在站点目录下的themes目录下)</span><br></pre></td></tr></table></figure>
<p>官网有提供<a href="https://hexo.io" target="_blank" rel="noopener">主题列表</a>可以选择，当然你也可以做自己的主题</p>
<p>另外，主题也有自己的主题配置文件 _config.yml，存放主题自己的一些配置。主题配置文件位置在主题目录下。</p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>同样，hexo提供了插件功能，可以提供很多生成、发布和运行等的功能。<br>例如可以生成静态网站后，通过插件<a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a>将生成的内容发布到git.<br>利用这个插件搭配<a href="https://pages.github.com/" target="_blank" rel="noopener">github.io</a>,可以实现自动生成&amp;部署自己的网站。</p>
<h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>

<p>Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。<br>如果不想文章被布局处理，可以将 Front-Matter 中的layout: 设为 false 。</p>
<table>
<thead>
<tr>
<th>布局</th>
<th align="center">路径</th>
</tr>
</thead>
<tbody><tr>
<td>post</td>
<td align="center">source/_posts</td>
</tr>
<tr>
<td>page</td>
<td align="center">source</td>
</tr>
<tr>
<td>draft</td>
<td align="center">source/_drafts</td>
</tr>
</tbody></table>
<blockquote class="blockquote-center"><p>更多的写作可以参考<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">官网</a>.</p>
<p>建议创建页面 : tags 和categories 页面,生成的时候可以自动生成<a href="(http://localhost:4000/categories/)">分类</a>和<a href="http://localhost:4000/tags/" target="_blank" rel="noopener">标签</a>页面的内容。</p>
</blockquote> 

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>

<h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<p>默认将静态网站生成到 public 目录下，生成完成后就可以将 public 目录下的内容发布到静态网站服务器上。</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>可以使用 hexo server 命令，本地启动服务器，运行网站</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>默认启动端口为 4000 的服务端，可以使用 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000</a> 访问。</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="代码托管"><a href="#代码托管" class="headerlink" title="代码托管"></a>代码托管</h3><p>将创建的网站仓库托管到github，注册等过程不表。</p>
<p>配置自己的<a href="https://github.com/dp9u0/HexoBlog" target="_blank" rel="noopener">网站仓库</a>，然后就可以git commit &amp; git push ,将源码推送到github上。这样就可以随时编辑自己的网站了。</p>
<p>不必要的内容不需要提交，可以使用  .gitignore， 贴一下自己的 .gitignore 文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Logs</span><br><span class="line">logs</span><br><span class="line">*.log</span><br><span class="line">npm-debug.log*</span><br><span class="line"></span><br><span class="line"># Runtime data</span><br><span class="line">pids</span><br><span class="line">*.pid</span><br><span class="line">*.seed</span><br><span class="line"></span><br><span class="line"># Directory for instrumented libs generated by jscoverage&#x2F;JSCover</span><br><span class="line">lib-cov</span><br><span class="line"></span><br><span class="line"># Coverage directory used by tools like istanbul</span><br><span class="line">coverage</span><br><span class="line"></span><br><span class="line"># nyc test coverage</span><br><span class="line">.nyc_output</span><br><span class="line"></span><br><span class="line"># Grunt intermediate storage (http:&#x2F;&#x2F;gruntjs.com&#x2F;creating-plugins#storing-task-files)</span><br><span class="line">.grunt</span><br><span class="line"></span><br><span class="line"># node-waf configuration</span><br><span class="line">.lock-wscript</span><br><span class="line"></span><br><span class="line"># Compiled binary addons (http:&#x2F;&#x2F;nodejs.org&#x2F;api&#x2F;addons.html)</span><br><span class="line">build&#x2F;Release</span><br><span class="line"></span><br><span class="line"># Dependency directories</span><br><span class="line">node_modules</span><br><span class="line">jspm_packages</span><br><span class="line"></span><br><span class="line"># Optional npm cache directory</span><br><span class="line">.npm</span><br><span class="line"></span><br><span class="line"># Optional REPL history</span><br><span class="line">.node_repl_history</span><br><span class="line"></span><br><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">public&#x2F;</span><br><span class="line">.deploy*&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="自动部署云服务器"><a href="#自动部署云服务器" class="headerlink" title="自动部署云服务器"></a>自动部署云服务器</h3><p>在云服务器(ubuntu 16.04)上安装 nodejs 、git 、hexo-cli</p>
<p>然后clone 到仓库本地：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~ </span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;dp9u0&#x2F;HexoBlog</span><br></pre></td></tr></table></figure>

<p>创建周期执行的呼叫脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi CallHexoBlogAutoUpdate.sh</span><br></pre></td></tr></table></figure>

<p>CallHexoBlogAutoUpdate.sh脚本中，添加以下内容，呼叫仓库中的自动更新脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">. ~&#x2F;HexoBlog&#x2F;AutoUpdate.sh</span><br></pre></td></tr></table></figure>
<blockquote class="blockquote-center"><p>为什么要有两个脚本: CallHexoBlogAutoUpdate.sh  和 AutoUpdate.sh?<br>不知道怎么给 AutoUpdate.sh 添加权限 ，不同的操作系统clone后，权限依旧保留。<br>同时 . ~/HexoBlog/AutoUpdate.sh 如果直接配置在 crontab 环境变量好像有点问题。<br>因此将所以自动更新的逻辑放在 AutoUpdate.sh 并且在每个需要执行自动更新的机器上添加外壳程序 CallHexoBlogAutoUpdate.sh  用点符号执行脚本 AutoUpdate.sh。<br>并且外壳程序添加到定时任务中。</p>
</blockquote>

<p>调用的自动更新脚本（该脚本加入到git仓库中，可以自更新）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">LOG_FILE&#x3D;~&#x2F;HexoBlogAutoUpdate.log</span><br><span class="line">echo &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &gt;&gt; $LOG_FILE</span><br><span class="line">echo $(date +%y_%m_%d_%H_%I_%T) &gt;&gt; $LOG_FILE</span><br><span class="line">echo &quot;----------------------------------------&quot; &gt;&gt; $LOG_FILE</span><br><span class="line">if [ $1 ] ; then        </span><br><span class="line">    echo &quot;first argument is not empty : $1&quot; &gt;&gt; $LOG_FILE</span><br><span class="line">    TAR_DIR&#x3D;$1 </span><br><span class="line">    echo &quot;use first argument as target dir : $TAR_DIR&quot; &gt;&gt; $LOG_FILE</span><br><span class="line">else</span><br><span class="line">    echo &quot;first argument is empty&quot; &gt;&gt; $LOG_FILE  </span><br><span class="line">    # use  ~&#x2F;HexoBlog as the default dir    </span><br><span class="line">    TAR_DIR&#x3D;~&#x2F;HexoBlog # 修改为你需要的默认路径</span><br><span class="line">    echo &quot;use default dir as target dir : $TAR_DIR&quot; &gt;&gt; $LOG_FILE</span><br><span class="line">fi </span><br><span class="line">echo &quot;----------------------------------------&quot; &gt;&gt; $LOG_FILE</span><br><span class="line">if [ -d $TAR_DIR ] ; then </span><br><span class="line">    echo &quot;$TAR_DIR is a dir,try update&quot; &gt;&gt; $LOG_FILE</span><br><span class="line">    cd $TAR_DIR</span><br><span class="line">    echo &quot;++++++++++++++++++++++++++++++++++++++++&quot; &gt;&gt; $LOG_FILE</span><br><span class="line">    git pull &gt;&gt; $LOG_FILE # 同步git</span><br><span class="line">    echo &quot;++++++++++++++++++++++++++++++++++++++++&quot; &gt;&gt; $LOG_FILE</span><br><span class="line">    killall hexo &gt;&gt; $LOG_FILE # 关闭 hexo server</span><br><span class="line">    echo &quot;++++++++++++++++++++++++++++++++++++++++&quot; &gt;&gt; $LOG_FILE</span><br><span class="line">    hexo clean &gt;&gt; $LOG_FILE # 清理 </span><br><span class="line">    echo &quot;++++++++++++++++++++++++++++++++++++++++&quot; &gt;&gt; $LOG_FILE</span><br><span class="line">    hexo g &gt;&gt; $LOG_FILE # 生成</span><br><span class="line">    echo &quot;++++++++++++++++++++++++++++++++++++++++&quot; &gt;&gt; $LOG_FILE</span><br><span class="line">    hexo server &amp;  # 启动 hexo server</span><br><span class="line">    echo &quot;++++++++++++++++++++++++++++++++++++++++&quot; &gt;&gt; $LOG_FILE</span><br><span class="line">    hexo d &gt;&gt; $LOG_FILE   # 自动 </span><br><span class="line">    echo &quot;++++++++++++++++++++++++++++++++++++++++&quot; &gt;&gt; $LOG_FILE</span><br><span class="line">else</span><br><span class="line">    echo &quot;$TAR_DIR is not a dir,do nothing&quot; &gt;&gt; $LOG_FILE</span><br><span class="line">fi</span><br><span class="line">echo &quot;----------------------------------------&quot; &gt;&gt; $LOG_FILE</span><br><span class="line">echo $(date +%y_%m_%d_%H_%I_%T) &gt;&gt; $LOG_FILE</span><br><span class="line">echo &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &gt;&gt; $LOG_FILE</span><br></pre></td></tr></table></figure>

<p>添加 CallHexoBlogAutoUpdate 脚本执行权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x CallHexoBlogAutoUpdate.sh</span><br></pre></td></tr></table></figure>

<p>添加定时任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure>

<p>添加如下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*&#x2F;5 * * * *  ~&#x2F;CallHexoBlogAutoUpdate.sh # 五分钟执行检查一次更新</span><br></pre></td></tr></table></figure>

<h3 id="github-io"><a href="#github-io" class="headerlink" title="github.io"></a>github.io</h3><p>hexo deploy 命令根据站点配置文件_config.yml中的配置，将生成的内容发布到站点中。</p>
<p>其中不同的type需要特殊的插件支持。<br>例如发布到git上，需要插件<a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a></p>
<p>首先创建自己的<a href="https://github.com/dp9u0/dp9u0.github.io" target="_blank" rel="noopener">github.io仓库</a></p>
<blockquote class="blockquote-center"><p>关于github.io:如果建立了 用户名.github.io 的仓库，github会定时将这个仓库的静态页面发布到 用户名.github.io 的站点上.<br>可以了解更多关于 <a href="github.io">github.io</a>的内容</p>
</blockquote> 

<p>站点配置文件配置参考如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:dp9u0&#x2F;dp9u0.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<blockquote class="blockquote-center"><p>部署到git，需要有你的github仓库的push权限，可以参考<a href="https://help.github.com/articles/connecting-to-github-with-ssh/" target="_blank" rel="noopener">github文档</a>中关于<a href="https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/" target="_blank" rel="noopener">生成 SSH Key</a><br>以及<a href="https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/" target="_blank" rel="noopener">添加SSH Key</a>的部分，配置通过SSH免密码push代码到github。</p>
</blockquote> 

<p>然后，就可以运行生成部署命令了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>这些也可以添加到AutoUpdate.sh脚本中，这样我只需要在自己的个人电脑上hexo new ,编辑自己的网站，然后git commit 提交，再执行git push到推送到 将源码推送到github上。这样就可以随时编辑自己的网站了。<br>部署在云服务器上的<a href="http://baochen.name:4000">网站</a> 和<a href="https://dp9u0.github.io" target="_blank" rel="noopener">github.io</a> 上的内容，都会自动更新了！</p>
]]></content>
      <categories>
        <category>knowledge</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 入门</title>
    <url>/2018/04/08/docker-intro/</url>
    <content><![CDATA[<blockquote class="blockquote-center"><p>开发人员总是会这么说：“在我的机器上是正常的呀！”<br>这就是开发过程中避免不了的一个问题：开发和上线环境不一致的问题。<br>Docker作为一种解决方案，很好的解决了这个问题。</p>
</blockquote>

<a id="more"></a>

<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#背景">背景</a></li>
<li><a href="#安装">安装</a></li>
<li><a href="#HelloWorld">HelloWorld</a></li>
<li><a href="#Image">Image</a></li>
<li><a href="#Container">Container</a></li>
<li><a href="#制作自己的Image">制作自己的Image</a></li>
<li><a href="#微服务">微服务</a></li>
</ul>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>虚拟化技术应用非常广泛，主要有虚拟机和容器(LXC)两种。<br>虚拟机尤其有点也有缺点，冗余，占用资源高，启动慢，为此，诞生了Linux容器技术即LXC。<br>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>根据官网教程选择自己的平台对应的<a href="https://docs.docker.com/install/" target="_blank" rel="noopener">安装指引</a></p>
<p>安装完成后，在命令行中运行查看是否安装成功:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker version</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker info</span></span><br></pre></td></tr></table></figure>

<p>Docker 是服务器—-客户端架构。命令行运行docker命令的时候，需要本机有 Docker 服务。如果这项服务没有启动，可以用下面的命令启动(Linux宿主机。Windows 不需要)。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> service 命令的用法</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo service docker start</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl 命令的用法</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl start docker</span></span><br></pre></td></tr></table></figure>

<p>补充一句，Windows下的Docker实际是通过Hyper-V创建了Linux虚拟机运行的。这个虚拟机已经配置好Docker的运行环境。</p>
<h1 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">运行下面的命令，将 image 文件从仓库抓取到本地。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker image pull library/hello-world</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">上面代码中，docker image pull是抓取 image 文件的命令。library/hello-world是 image 文件在仓库里面的位置，其中library是 image 文件所在的组，hello-world是 image 文件的名字。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">由于 Docker 官方提供的 image 文件，都放在library组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker image pull hello-world</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">抓取成功以后，就可以在本机看到这个 image 文件了。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker image ls</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">运行</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker container run hello-world</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以看到类似下面的输出</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Hello from Docker!</span></span><br><span class="line"><span class="meta">#</span><span class="bash">This message shows that your installation appears to be working correctly.</span></span><br></pre></td></tr></table></figure>

<p>或者，可以直接输入命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container run hello-world</span><br></pre></td></tr></table></figure>

<p>docker 会自动查找Image，如果本地没有，会从官方仓库中pull，然后运行。</p>
<p>另外可以安装运行 Ubuntu</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container run -it ubuntu bash</span><br></pre></td></tr></table></figure>

<p>但是安装的Ubuntu是以服务运行的，并不会自动停止，需要使用kill命令停止</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container kill [containID]</span><br></pre></td></tr></table></figure>

<h1 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h1><p>Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p>
<p>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出本机的所有 image 文件。</span></span><br><span class="line">docker image ls</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除 image 文件</span></span><br><span class="line">docker image rm [imageName]</span><br><span class="line">image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。</span><br></pre></td></tr></table></figure>

<p>为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 Docker Hub 是最重要、最常用的 image 仓库。此外，出售自己制作的 image 文件也是可以的。</p>
<h1 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h1><p>image 文件生成的容器实例，本身也是一个文件，称为容器文件。也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出本机正在运行的容器</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker container ls</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出本机所有容器，包括终止运行的容器</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker container ls --all</span></span><br></pre></td></tr></table></figure>

<p>上面命令的输出结果之中，包括容器的 ID。很多地方都需要提供这个 ID，比如上一节终止容器运行的docker container kill命令。</p>
<p>终止运行的容器文件，依然会占据硬盘空间，可以使用docker container rm命令删除。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker container rm [containerID]</span></span><br><span class="line">运行上面的命令之后，再使用docker container ls --all命令，就会发现被删除的容器文件已经消失了。</span><br></pre></td></tr></table></figure>

<h1 id="制作自己的Image"><a href="#制作自己的Image" class="headerlink" title="制作自己的Image"></a>制作自己的Image</h1><p>下面以 koa-demos 项目为例，介绍怎么写 Dockerfile 文件，实现让用户在 Docker 容器里面运行 Koa 框架。<br>作为准备工作，请先下载源码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">作为准备工作，请先下载源码。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/ruanyf/koa-demos.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> koa-demos</span></span><br></pre></td></tr></table></figure>

<p>接下来编写 Dockerfile 文件，首先，在项目的根目录下，新建一个文本文件.dockerignore，写入下面的内容。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.git</span><br><span class="line">node_modules</span><br><span class="line">npm-debug.log</span><br></pre></td></tr></table></figure>

<p>上面代码表示，这三个路径要排除，不要打包进入 image 文件。如果你没有路径要排除，这个文件可以不新建。</p>
<p>然后，在项目的根目录下，新建一个文本文件 Dockerfile，写入下面的内容。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM node:8.4 #该 image 文件继承官方的 node image，冒号表示标签，这里标签是8.4，即8.4版本的 node。</span><br><span class="line">COPY . /app #将当前目录下的所有文件（除了.dockerignore排除的路径），都拷贝进入 image 文件的/app目录。</span><br><span class="line">WORKDIR /app #指定接下来的工作路径为/app。</span><br><span class="line">RUN npm install --registry=https://registry.npm.taobao.org #在/app目录下，运行npm install命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。</span><br><span class="line">EXPOSE 3000 #将容器 3000 端口暴露出来， 允许外部连接这个端口。</span><br></pre></td></tr></table></figure>

<p>上面代码一共五行，含义如下:<br>FROM node:8.4：该 image 文件继承官方的 node image，冒号表示标签，这里标签是8.4，即8.4版本的 node。<br>COPY . /app：将当前目录下的所有文件（除了.dockerignore排除的路径），都拷贝进入 image 文件的/app目录。<br>WORKDIR /app：指定接下来的工作路径为/app。<br>RUN npm install：在/app目录下，运行npm install命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。<br>EXPOSE 3000：将容器 3000 端口暴露出来， 允许外部连接这个端口。</p>
<p>接下来创建 image 文件，使用docker image build命令创建 image 文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image build -t koa-demo .</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker image build -t koa-demo:0.0.1 .</span></span><br><span class="line">上面代码中，-t参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是latest。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。</span><br></pre></td></tr></table></figure>

<p>如果运行成功，就可以看到新生成的 image 文件koa-demo了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure>

<p>docker container run命令会从 image 文件生成容器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker container run -p 8000:3000 -it koa-demo /bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker container run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash</span></span><br></pre></td></tr></table></figure>

<p>上面命令的各个参数含义如下：</p>
<p>-p参数：容器的 3000 端口映射到本机的 8000 端口。<br>-it参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。<br>koa-demo:0.0.1：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。<br>/bin/bash：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。<br>如果一切正常，运行上面的命令以后，就会返回一个命令行提示符。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@66d80f4aaf1e:/app#</span><br><span class="line"><span class="meta">#</span><span class="bash">这表示你已经在容器里面了，返回的提示符就是容器内部的 Shell 提示符。执行下面的命令。</span></span><br><span class="line"></span><br><span class="line">root@66d80f4aaf1e:/app# node demos/01.js</span><br><span class="line"><span class="meta">#</span><span class="bash">这时，Koa 框架已经运行起来了。打开本机的浏览器，访问 http://127.0.0.1:8000，网页显示<span class="string">"Not Found"</span>，这是因为这个 demo 没有写路由。</span></span><br></pre></td></tr></table></figure>

<p>这个例子中，Node 进程运行在 Docker 容器的虚拟环境里面，进程接触到的文件系统和网络接口都是虚拟的，与本机的文件系统和网络接口是隔离的，因此需要定义容器与物理机的端口映射（map）。<br>现在，在容器的命令行，按下 Ctrl + c 停止 Node 进程，然后按下 Ctrl + d （或者输入 exit）退出容器。此外，也可以用docker container kill终止容器运行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在本机的另一个终端窗口，查出容器的 ID</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker container ls</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止指定的容器运行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker container <span class="built_in">kill</span> [containerID]</span></span><br><span class="line">容器停止运行之后，并不会消失，用下面的命令删除容器文件。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查出容器的 ID</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker container ls --all</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除指定的容器文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker container rm [containerID]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以使用docker container run命令的--rm参数，在容器终止运行后自动删除容器文件。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker container run --rm -p 8000:3000 -it koa-demo /bin/bash</span></span><br></pre></td></tr></table></figure>

<p>最后说一下CMD 命令，上面说到容器启动以后，需要手动输入命令node demos/01.js。我们可以把这个命令写在 Dockerfile 里面，这样容器启动以后，这个命令就已经执行了，不用再手动输入了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM node:8.4</span><br><span class="line">COPY . /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">RUN npm install --registry=https://registry.npm.taobao.org</span><br><span class="line">EXPOSE 3000</span><br><span class="line">CMD node demos/01.js</span><br></pre></td></tr></table></figure>

<p>上面的 Dockerfile 里面，多了最后一行CMD node demos/01.js，它表示容器启动后自动执行node demos/01.js。</p>
<p>RUN命令与CMD命令的区别在哪里？简单说，RUN命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；CMD命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个RUN命令，但是只能有一个CMD命令。</p>
<p>注意，指定了CMD命令以后，docker container run命令就不能附加命令了（比如前面的/bin/bash），否则它会覆盖CMD命令。现在，启动容器可以使用下面的命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container run --rm -p 8000:3000 -it koa-demo:0.0.1</span><br></pre></td></tr></table></figure>

<p>最后的最后，是发布 image 文件，容器运行成功后，就确认了 image 文件的有效性。这时，我们就可以考虑把 image 文件分享到网上，让其他人使用。</p>
<p>首先，去 hub.docker.com 或 cloud.docker.com 注册一个账户。然后，用下面的命令登录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker login</span></span><br><span class="line"><span class="meta">#</span><span class="bash">接着，为本地的 image 标注用户名和版本。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker image tag [imageName] [username]/[repository]:[tag]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 实例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker image tag koa-demos:0.0.1 guodp9u0/koa-demos:0.0.1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">也可以不标注用户名，重新构建一下 image 文件。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker image build -t [username]/[repository]:[tag] .</span></span><br><span class="line"><span class="meta">#</span><span class="bash">最后，发布 image 文件。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker image push [username]/[repository]:[tag]</span></span><br></pre></td></tr></table></figure>

<p>发布成功以后，登录 hub.docker.com，就可以看到已经发布的 image 文件。</p>
<p>docker 的主要用法就是上面这些，此外还有几个命令，也非常有用。</p>
<ul>
<li>docker container start</li>
</ul>
<p>前面的docker container run命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器，就要使用docker container start命令，它用来启动已经生成、已经停止运行的容器文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container start [containerID]</span><br></pre></td></tr></table></figure>

<ul>
<li>docker container stop</li>
</ul>
<p>前面的docker container kill命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而docker container stop命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash container stop [containerID]</span><br></pre></td></tr></table></figure>

<p>这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。</p>
<ul>
<li>docker container logs</li>
</ul>
<p>docker container logs命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果docker run命令运行容器的时候，没有使用-it参数，就要用这个命令查看输出。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container logs [containerID]</span><br></pre></td></tr></table></figure>

<ul>
<li>docker container exec</li>
</ul>
<p>docker container exec命令用于进入一个正在运行的 docker 容器。如果docker run命令运行容器的时候，没有使用-it参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container exec -it [containerID] /bin/bash</span><br></pre></td></tr></table></figure>

<ul>
<li>docker container cp</li>
</ul>
<p>docker container cp命令用于从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container cp [containID]:[/path/to/file] .</span><br></pre></td></tr></table></figure>

<h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><h2 id="DIY-wordpress"><a href="#DIY-wordpress" class="headerlink" title="DIY wordpress"></a>DIY wordpress</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">启动 mysql 镜像</span></span><br><span class="line">sudo docker container run \</span><br><span class="line">  -d \ #后台运行</span><br><span class="line">  --rm \ #停止后删除</span><br><span class="line">  --name wordpressdb \ #指定名称</span><br><span class="line">  --env MYSQL_ROOT_PASSWORD=123456 \  #环境变量</span><br><span class="line">  --env MYSQL_DATABASE=wordpress \ #环境变量</span><br><span class="line">  mysql:5.7</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建工作目录</span></span><br><span class="line">mkdir docker-demo &amp;&amp; cd  docker-demo</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载 wordpress</span></span><br><span class="line"></span><br><span class="line">wget https://cn.wordpress.org/wordpress-4.9.4-zh_CN.tar.gz</span><br><span class="line">tar -xvf wordpress-4.9.4-zh_CN.tar.gz</span><br><span class="line">hmod -R 777 wordpress #可写</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">基于php镜像创建 安装mysqli的镜像</span></span><br><span class="line">vi Dockerfile</span><br><span class="line"><span class="meta">#</span><span class="bash">输入文本 :</span></span><br><span class="line"><span class="meta">#</span><span class="bash">FROM php:5.6-apache</span></span><br><span class="line"><span class="meta">#</span><span class="bash">RUN docker-php-ext-install mysqli</span></span><br><span class="line"><span class="meta">#</span><span class="bash">CMD apache2-foreground</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">生成镜像</span></span><br><span class="line">docker build -t phpwithmysql .</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">启动镜像</span></span><br><span class="line"></span><br><span class="line">sudo docker container run \</span><br><span class="line">  --rm \</span><br><span class="line">  --name wordpress \</span><br><span class="line">  --volume "$PWD/":/var/www/html \ #当前目录映射到container的 /var/www/html</span><br><span class="line">  --link wordpressdb:mysql \ #连接已有的container并提供别名</span><br><span class="line">  phpwithmysql</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">浏览器查看 http://172.17.0.2/wordpress</span></span><br><span class="line"><span class="meta">#</span><span class="bash">具体地址根据实际情况替换IP即可</span></span><br></pre></td></tr></table></figure>

<h2 id="官方-wordpress-镜像"><a href="#官方-wordpress-镜像" class="headerlink" title="官方 wordpress 镜像"></a>官方 wordpress 镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">使用mysql镜像 启动container</span></span><br><span class="line">sudo docker container run \</span><br><span class="line">  -d \ #后台运行</span><br><span class="line">  --rm \ #停止后删除</span><br><span class="line">  --name wordpressdb \ #指定名称</span><br><span class="line">  --env MYSQL_ROOT_PASSWORD=123456 \  #环境变量</span><br><span class="line">  --env MYSQL_DATABASE=wordpress \ #环境变量</span><br><span class="line">  mysql:5.7</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用官方提供的wordpress镜像启动container</span></span><br><span class="line"></span><br><span class="line">sudo docker container run \</span><br><span class="line">  -d \</span><br><span class="line">  -p 127.0.0.2:8080:80 \</span><br><span class="line">  --rm \</span><br><span class="line">  --name wordpress \</span><br><span class="line">  --env WORDPRESS_DB_PASSWORD=123456 \</span><br><span class="line">  --link wordpressdb:mysql \</span><br><span class="line">  --volume "$PWD/wordpress":/var/www/html \</span><br><span class="line">  wordpress</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看container信息</span></span><br><span class="line"></span><br><span class="line">sudo docker container inspect wordpress</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">由于做了IP和端口映射 因此可以直接</span></span><br><span class="line"><span class="meta">#</span><span class="bash">浏览器查看 http://127.0.0.2:8080/wordpress</span></span><br></pre></td></tr></table></figure>

<h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><p><a href="https://docs.docker.com/compose/install/#install-compose" target="_blank" rel="noopener">安装Docker Compose</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动所有服务</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker-compose up</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭所有服务</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker-compose stop</span></span><br><span class="line"></span><br><span class="line">cd docker-demo</span><br><span class="line">vi docker-compose.yml</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">输入下面内容</span></span><br><span class="line"></span><br><span class="line">mysql:</span><br><span class="line">    image: mysql:5.7</span><br><span class="line">    environment:</span><br><span class="line">     - MYSQL_ROOT_PASSWORD=123456</span><br><span class="line">     - MYSQL_DATABASE=wordpress</span><br><span class="line">web:</span><br><span class="line">    image: wordpress</span><br><span class="line">    links:</span><br><span class="line">     - mysql</span><br><span class="line">    environment:</span><br><span class="line">     - WORDPRESS_DB_PASSWORD=123456</span><br><span class="line">    ports:</span><br><span class="line">     - "127.0.0.3:8080:80"</span><br><span class="line">    working_dir: /var/www/html</span><br><span class="line">    volumes:</span><br><span class="line">     - wordpress:/var/www/html</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 compose</span></span><br><span class="line"></span><br><span class="line">docker-compose up</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">浏览器访问 http://127.0.0.3:8080</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">关闭</span></span><br><span class="line">docker-compose stop</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">移除</span></span><br><span class="line">docker-compose rm</span><br></pre></td></tr></table></figure>

<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p>安装完 Ununtu 建议替换默认源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i 's/http:\/\/archive.ubuntu.com\/ubuntu\//http:\/\/mirrors.163.com\/ubuntu\//g' /etc/apt/sources.list</span><br><span class="line"><span class="meta">#</span><span class="bash">or</span></span><br><span class="line">cd /etc/apt-get</span><br><span class="line">mv sources.list sources.list.bak</span><br><span class="line">echo deb http://mirrors.163.com/debian/ jessie main non-free contrib &gt;&gt; sources.list</span><br><span class="line">echo deb http://mirrors.163.com/debian/ jessie-updates main non-free contrib &gt;&gt; sources.list</span><br><span class="line">echo deb http://mirrors.163.com/debian/ jessie-backports main non-free contrib &gt;&gt; sources.list</span><br><span class="line">echo deb-src http://mirrors.163.com/debian/ jessie main non-free contrib &gt;&gt; sources.list</span><br><span class="line">echo deb-src http://mirrors.163.com/debian/ jessie-updates main non-free contrib &gt;&gt; sources.list</span><br><span class="line">echo deb-src http://mirrors.163.com/debian/ jessie-backports main non-free contrib &gt;&gt; sources.list</span><br><span class="line">echo deb http://mirrors.163.com/debian-security/ jessie/updates main non-free contrib &gt;&gt; sources.list</span><br><span class="line">echo deb-src http://mirrors.163.com/debian-security/ jessie/updates main non-free contrib &gt;&gt; sources.list</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 原型链</title>
    <url>/2018/09/04/javascript-proto/</url>
    <content><![CDATA[<p>介绍Javascript原型链</p>
<a id="more"></a>

<h1 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h1><h2 id="普通实例-对象-和函数实例-对象"><a href="#普通实例-对象-和函数实例-对象" class="headerlink" title="普通实例(对象)和函数实例(对象)"></a>普通实例(对象)和函数实例(对象)</h2><p>首先搞清楚一个概念 : 实例</p>
<blockquote>
<p>我更喜欢用“实例(instance)”而不是“对象(object)”,当阅读到时,知道是一种东西即可.</p>
</blockquote>
<p>简单来说: <strong>实例</strong> 是通过 <em>构造函数</em> <em>new</em> 出来的.</p>
<p>Javascript中一切都可以是实例,但是实例之间又有所不同:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// Foo : instance &amp; constructor</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo(); <span class="comment">// foo1 : Instance</span></span><br><span class="line"><span class="keyword">let</span> Bar = <span class="keyword">new</span> <span class="built_in">Function</span>(); <span class="comment">//instance 相当于 function Bar()&#123;&#125;</span></span><br><span class="line"><span class="keyword">let</span> ob1 = &#123;&#125; <span class="comment">// Instance 语法糖,相当于 new Object()</span></span><br><span class="line"><span class="keyword">let</span> ob2 = <span class="keyword">new</span> <span class="built_in">Object</span>();<span class="comment">// Instance</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo);<span class="comment">//foo是Object类型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> ob1);<span class="comment">//ob1是Object类型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> ob2);<span class="comment">//ob2是Object类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Foo);<span class="comment">//Foo是Function类型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Bar);<span class="comment">//Bar是Function类型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>);<span class="comment">//Object 是Function类型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Date</span>);<span class="comment">//Date是Function类型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>);<span class="comment">//Function是Function类型</span></span><br><span class="line"><span class="comment">// =&gt;</span></span><br><span class="line"><span class="comment">// object</span></span><br><span class="line"><span class="comment">// object</span></span><br><span class="line"><span class="comment">// object</span></span><br><span class="line"><span class="comment">// function</span></span><br><span class="line"><span class="comment">// function</span></span><br><span class="line"><span class="comment">// function</span></span><br><span class="line"><span class="comment">// function</span></span><br><span class="line"><span class="comment">// function</span></span><br></pre></td></tr></table></figure>

<p>1.2.3都比较好理解.<br>4.5.6.7:这是由于Javascript的定义:所有<em>函数</em>(例如上面自定义的Foo,Bar,内置的Object,Date甚至Function本身)都是由<code>Function</code>创建的实例.</p>
<p>可以看到正常的创建一个实例的方法为: 调用 new <em>constructor()</em></p>
<p>Javascript 也提供了一些语法糖.可以用来创建实例,例如 <code>function Foo(){}</code> 或者 <code>let obj = {}</code>,可以简单认为,其本质还是通过new来创建的.</p>
<p><strong>最终得出的概念是: 实例或者对象就是 <code>let foo = new Foo();</code> 中通过new后面的Foo(构造函数)构造出来的东西</strong></p>
<p>同时对象可以分为普通实例和函数实例:</p>
<ul>
<li>foo、ob1、ob2 等称为普通实例.通过诸如 Foo()、 Object() 等构造函数构造出来.</li>
<li>Foo、Bar、Object 等比较特殊,称为函数实例 : 既可以作为构造函数(可以new实例),本身又是个实例,通过构造函数Function构造造出来,例如 <code>let Bar =  new Function()</code> 或者 <code>function Foo(){}</code></li>
</ul>
<h2 id="构造函数-函数实例"><a href="#构造函数-函数实例" class="headerlink" title="构造函数(函数实例)"></a>构造函数(函数实例)</h2><p>当使用 <code>let foo = new Foo()</code> 的时候 Foo 就是 foo 的构造函数:</p>
<blockquote>
<p>Javascript有个比较奇怪的地方foo是个Foo的实例(foo instanceof Foo),但是foo的类型(typeof foo)却是Object</p>
<p>这个暂时想不明白为什么(可能是弱类型的原因),因此在描述实例的”类型”,会尽量避免使用”类型”这一概念,而使用”实例的构造函数”.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> foo1 = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="keyword">let</span> foo2 = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`foo1的构造函数为 : <span class="subst">$&#123;foo1.constructor&#125;</span>,</span></span><br><span class="line"><span class="string">foo1和foo2的构造函数相等 : <span class="subst">$&#123;foo1.constructor === foo2.constructor&#125;</span>,</span></span><br><span class="line"><span class="string">这是因为foo1,foo2的构造函数都是 Foo : <span class="subst">$&#123;foo1.constructor === Foo &amp;&amp; foo2.constructor === Foo&#125;</span>,</span></span><br><span class="line"><span class="string">即foo1 instance of Foo : <span class="subst">$&#123;foo1 <span class="keyword">instanceof</span> Foo&#125;</span>,</span></span><br><span class="line"><span class="string">即foo2 instance of Foo : <span class="subst">$&#123;foo2 <span class="keyword">instanceof</span> Foo&#125;</span>,</span></span><br><span class="line"><span class="string">`</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ob = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`实例都有对应的构造函数:</span></span><br><span class="line"><span class="string">ob : <span class="subst">$&#123;ob.constructor&#125;</span>,</span></span><br><span class="line"><span class="string">Foo : <span class="subst">$&#123;Foo.constructor&#125;</span>,</span></span><br><span class="line"><span class="string">Object : <span class="subst">$&#123;<span class="built_in">Object</span>.constructor&#125;</span>,</span></span><br><span class="line"><span class="string">Foo Object同时也作为函数实例,因此它们的构造函数相同,都是Function : <span class="subst">$&#123;Foo.constructor === <span class="built_in">Object</span>.constructor &amp;&amp; <span class="built_in">Object</span>.constructor === <span class="built_in">Function</span>&#125;</span></span></span><br><span class="line"><span class="string">`</span>);</span><br></pre></td></tr></table></figure>

<h2 id="prototype-和-proto"><a href="#prototype-和-proto" class="headerlink" title="prototype 和 proto"></a>prototype 和 <strong>proto</strong></h2><p>很多人搞不清prototype和<strong>proto</strong>的关系,两句话描述 :</p>
<ul>
<li>prototype是属于构造函数的,用来访问构造函数的原型</li>
<li><strong>proto</strong>是属于实例的,用来访问这个实例的构造函数的原型</li>
</ul>
<blockquote>
<p><strong>proto</strong>标准应该为属性:[[Prototype]],但是目前主流浏览器以及Node都为实例实现了getter:<strong>proto</strong>这个 <strong>非标准功能</strong>.</p>
</blockquote>
<p>即prototype和<strong>proto</strong> 都是用来访问一个特殊实例的,这个实例就是某个构造函数的原型(这个原型并不是通过构造函数构造的一个实例).</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(Foo.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(foo.__proto__);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`foo.__proto__ 等于 Foo.prototype(foo由Foo构造):<span class="subst">$&#123;foo.__proto__ === Foo.prototype&#125;</span>`</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`foo.__proto__ instance of Foo : <span class="subst">$&#123;foo.__proto__ <span class="keyword">instanceof</span> Foo&#125;</span>`</span>); <span class="comment">// 原型并不是通过构造函数构造的一个实例,即不是 new Foo()出来的</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`foo.__proto__ instance of Object : <span class="subst">$&#123;foo.__proto__ <span class="keyword">instanceof</span> <span class="built_in">Object</span>&#125;</span>`</span>); <span class="comment">// 原型是通过 new Object() 构造出来的</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`foo instance of Foo : <span class="subst">$&#123;foo <span class="keyword">instanceof</span> Foo&#125;</span>`</span>); <span class="comment">// foo 才是 Foo 的实例</span></span><br></pre></td></tr></table></figure>

<p>下图可以看出<strong>proto</strong>和prototype的区别与联系</p>
<img src="/2018/09/04/javascript-proto/proto.jpg" class="" title="原型">

<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>Javascript 原型的存在,目的是实现继承.当一个实例上一个属性不存在时,会去<strong>proto</strong>这个实例上去寻找,如果找不到会继续找取<strong>proto</strong>的<strong>proto</strong>去找…. 直到为空(实际如果在没有修改原型链的情况下,最终会找到Object.prototype的<strong>proto</strong>上,Object.prototype.__proto===null)</p>
<p>可以参照上图:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;foo.__proto__&#125;</span>`</span>); <span class="comment">// Foo.prototype</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;foo.__proto__.__prpto&#125;</span>`</span>); <span class="comment">// Foo.prototype.__proto__, Object.prototype</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;foo.__proto__.__prpto.__proto__&#125;</span>`</span>); <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<h2 id="普通对象和原型链"><a href="#普通对象和原型链" class="headerlink" title="普通对象和原型链"></a>普通对象和原型链</h2><p>先看一段代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">ag = <span class="number">10</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = ag;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.name = <span class="string">'foo.prototype'</span>;</span><br><span class="line">Foo.prototype.alert = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">`from <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> : age is <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>`</span>); &#125;</span><br><span class="line"><span class="keyword">let</span> f1 = <span class="keyword">new</span> Foo(<span class="number">11</span>);</span><br><span class="line">f1.name = <span class="string">'f1'</span>;</span><br><span class="line"><span class="keyword">let</span> f2 = <span class="keyword">new</span> Foo(<span class="number">13</span>);</span><br><span class="line">f1.alert(); <span class="comment">// 代码1</span></span><br><span class="line">f2.alert();</span><br><span class="line"><span class="comment">// f1.alert2(); // 代码2 f1.alert2 is not a function</span></span><br><span class="line"><span class="comment">// f2.alert2(); // f2.alert2 is not a function</span></span><br><span class="line">Foo.prototype = &#123; <span class="attr">name</span>: <span class="string">'foo.prototype2'</span>, <span class="attr">alert</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">`来自 <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> : 年龄是 <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>`</span>); &#125; &#125;;</span><br><span class="line"><span class="built_in">Object</span>.prototype.alert2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">`来自 Object.prototype :  <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span> !!!!!!!`</span>); &#125;;</span><br><span class="line"><span class="keyword">let</span> f3 = <span class="keyword">new</span> Foo(<span class="number">16</span>);</span><br><span class="line">f1.alert(); <span class="comment">// 依旧指向旧的prototype 代码3</span></span><br><span class="line">f2.alert(); <span class="comment">// 依旧指向旧的prototypeE</span></span><br><span class="line">f3.alert(); <span class="comment">// 代码4</span></span><br><span class="line"><span class="comment">// 通过 f.__proto__.__proto__ 找到 Object.prototype 上的方法</span></span><br><span class="line">f1.alert2(); <span class="comment">// 代码5</span></span><br><span class="line">f2.alert2();</span><br><span class="line">f3.alert2();</span><br></pre></td></tr></table></figure>

<ul>
<li>代码1: f1 f2 本身没有 alert方法 但是通过原型链 找到 f1.<strong>proto</strong>即 Foo.prototype 上有该方法,因此可以调用</li>
<li>代码2: 找到原型链的最后都没有找到 alert 因此不可调用</li>
<li>代码3: 这里首先要说明 new 操作做了什么事情: <code>let foo = new Foo()</code> 相当于三个步骤:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123;&#125;;</span><br><span class="line">foo.__proto__=Foo.prototype;</span><br><span class="line">Foo.call(foo);</span><br></pre></td></tr></table></figure>

<p>因此,foo.<strong>proto</strong>并不会随着 Foo.prototype的改变而改变</p>
<ul>
<li>代码4 : 同上</li>
<li>代码5 : 原型链查找</li>
</ul>
<p>常用对象原型链:</p>
<ul>
<li>Array</li>
</ul>
<p>new Array()._<em>proto_</em> =&gt; Array.prototype</p>
<p>new Array()._<em>proto_</em>._<em>proto_</em> = Array.prototype._<em>proto_</em> =&gt; Object.prototype</p>
<p>new Array()._<em>proto_</em>._<em>proto_</em>._<em>proto_</em> = Array.prototype._<em>proto_</em>._<em>proto_</em> = Object.prototype._<em>proto_</em> =&gt; null</p>
<ul>
<li>Object</li>
</ul>
<p>new Object()._<em>proto_</em> =&gt; Object.prototype</p>
<p>new Object()._<em>proto_</em>._<em>proto_</em> = Object.prototype._<em>proto_</em> =&gt; null</p>
<h2 id="函数对象和原型链"><a href="#函数对象和原型链" class="headerlink" title="函数对象和原型链"></a>函数对象和原型链</h2><p>函数对象原型链</p>
<ul>
<li>Function</li>
</ul>
<p>function Foo(){}</p>
<p>Foo._<em>proto_</em> =&gt; Function.prototype</p>
<p>Foo._<em>proto_</em>._<em>proto_</em> = Function.prototype._<em>proto_</em> =&gt; Object.prototype</p>
<p>Foo._<em>proto_</em>._<em>proto_</em>._<em>proto_</em> = Function.prototype._<em>proto_</em>._<em>proto_</em> =  Object.prototype._<em>proto_</em> =&gt; null</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(Foo));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(<span class="built_in">Function</span>.prototype));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(<span class="built_in">Object</span>.prototype));</span><br></pre></td></tr></table></figure>

<h2 id="proto-with-class"><a href="#proto-with-class" class="headerlink" title="proto with class"></a>proto with class</h2><p>ES6 引入了关键字 class,其本质还是跟原型链有一定关系的.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(height, width) &#123;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> area() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.height * <span class="keyword">this</span>.width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(sideLength) &#123;</span><br><span class="line">        <span class="keyword">super</span>(sideLength, sideLength);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> sideLength(newLength) &#123;</span><br><span class="line">        <span class="keyword">this</span>.height = newLength;</span><br><span class="line">        <span class="keyword">this</span>.width = newLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> Square(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(square.area);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Square is : <span class="subst">$&#123;<span class="keyword">typeof</span> Square&#125;</span>`</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Polygon is : <span class="subst">$&#123;<span class="keyword">typeof</span> Polygon&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(square));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`实例square 的 __proto__ 为类型 Square 的prototype : <span class="subst">$&#123;square.__proto__ === Square.prototype&#125;</span>`</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(square.__proto__)); <span class="comment">// Square.prototype</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`实例square 的 __proto__ 的 __proto__ 为类型 Polygon 的prototype : <span class="subst">$&#123;square.__proto__.__proto__ === Polygon.prototype&#125;</span>`</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(square.__proto__.__proto__));</span><br></pre></td></tr></table></figure>

<p>可以看出, <strong>class</strong> 其实算是个语法糖,其本质还是通过定义function即构造函数,然后构造对象,而 <strong>extend</strong> 则是通过设置原型链来实现继承</p>
]]></content>
      <categories>
        <category>knowledge</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>prototype</tag>
      </tags>
  </entry>
  <entry>
    <title>离职</title>
    <url>/2017/04/20/new-job-new-start/</url>
    <content><![CDATA[<p>准备换个新的工作环境了，已经找到，并且跟现在的公司申请了离职，顺利的话，5月10日就可以离开了。</p>
<p>update 20170427</p>
<p>测试</p>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>work</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Nginx运行网站</title>
    <url>/2017/02/24/server-with-nginx/</url>
    <content><![CDATA[<p>hexo server 不太好用，决定使用nginx。</p>
<a id="more"></a>

<p>首先在服务器上安装nginx，以ubuntu为例。使用apt-get安装比较方便，节省很多配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get nginx</span><br></pre></td></tr></table></figure>

<p>然后开始配置nginx：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;etc&#x2F;nginx</span><br><span class="line">sudp cp &#x2F;etc&#x2F;nginx&#x2F;nginx.conf &#x2F;etc&#x2F;nginx&#x2F;nginx.conf.bak</span><br><span class="line">sudo vi &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br></pre></td></tr></table></figure>

<p>配置内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user www-data;</span><br><span class="line"></span><br><span class="line">worker_processes auto;</span><br><span class="line"></span><br><span class="line">pid &#x2F;run&#x2F;nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">        worker_connections 768;</span><br><span class="line">        # multi_accept on;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">        ##</span><br><span class="line">        # Basic Settings</span><br><span class="line">        ##</span><br><span class="line"></span><br><span class="line">        sendfile on;</span><br><span class="line">        tcp_nopush on;</span><br><span class="line">        tcp_nodelay on;</span><br><span class="line">        keepalive_timeout 65;</span><br><span class="line">        types_hash_max_size 2048;</span><br><span class="line">        # server_tokens off;</span><br><span class="line"></span><br><span class="line">        # server_names_hash_bucket_size 64;</span><br><span class="line">        # server_name_in_redirect off;</span><br><span class="line"></span><br><span class="line">        include &#x2F;etc&#x2F;nginx&#x2F;mime.types;</span><br><span class="line">        default_type application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">        ##</span><br><span class="line">        # SSL Settings</span><br><span class="line">        ##</span><br><span class="line"></span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">        ##</span><br><span class="line">        # Logging Settings</span><br><span class="line">        ##</span><br><span class="line"></span><br><span class="line">        # log_format main &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39; &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39; &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">        error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log;</span><br><span class="line"></span><br><span class="line">        ##</span><br><span class="line">        # Gzip Settings</span><br><span class="line">        ##</span><br><span class="line"></span><br><span class="line">        gzip on;</span><br><span class="line">        gzip_disable &quot;msie6&quot;;</span><br><span class="line">        gzip_min_length 1k;</span><br><span class="line">        gzip_vary on;</span><br><span class="line">        gzip_proxied any;</span><br><span class="line">        gzip_comp_level 6;</span><br><span class="line">        gzip_buffers 16 8k;</span><br><span class="line">        gzip_http_version 1.1;</span><br><span class="line">        gzip_types text&#x2F;plain text&#x2F;css application&#x2F;json application&#x2F;javascript text&#x2F;xml application&#x2F;xml application&#x2F;xml+rss text&#x2F;javascript;</span><br><span class="line"></span><br><span class="line">        ##</span><br><span class="line">        # Http Proxy Settings</span><br><span class="line">        ##</span><br><span class="line">        client_max_body_size   10m;</span><br><span class="line">        client_body_buffer_size   128k;</span><br><span class="line">        proxy_connect_timeout   75;</span><br><span class="line">        proxy_send_timeout   75;</span><br><span class="line">        proxy_read_timeout   75;</span><br><span class="line">        proxy_buffer_size   4k;</span><br><span class="line">        proxy_buffers   4 32k;</span><br><span class="line">        proxy_busy_buffers_size   64k;</span><br><span class="line">        proxy_temp_file_write_size  64k;</span><br><span class="line">        proxy_temp_path   &#x2F;tmp&#x2F;proxy_temp 1 2;</span><br><span class="line"></span><br><span class="line">        ##</span><br><span class="line">        # Upstream Settings</span><br><span class="line">        ##</span><br><span class="line"></span><br><span class="line">        upstream  backend  &#123; </span><br><span class="line">              ip_hash; </span><br><span class="line">              server   127.0.0.1:4000 max_fails&#x3D;2 fail_timeout&#x3D;30s ;  </span><br><span class="line">              # server   192.168.10.101:8080 max_fails&#x3D;2 fail_timeout&#x3D;30s ;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ##</span><br><span class="line">        # Server Settings</span><br><span class="line">        ##</span><br><span class="line"></span><br><span class="line">        ## Server baochen.name</span><br><span class="line"></span><br><span class="line">        server &#123;</span><br><span class="line"></span><br><span class="line">                listen       80;</span><br><span class="line">                server_name  baochen.name;</span><br><span class="line">                charset utf-8;</span><br><span class="line">        </span><br><span class="line">                access_log      &#x2F;var&#x2F;log&#x2F;nginx&#x2F;baochen.name.access.log;</span><br><span class="line">                error_log       &#x2F;var&#x2F;log&#x2F;nginx&#x2F;baochen.name.error.log;</span><br><span class="line">        </span><br><span class="line">                location &#x2F; &#123;</span><br><span class="line">                        # proxy_pass        http:&#x2F;&#x2F;backend;  </span><br><span class="line">                        # proxy_redirect off;</span><br><span class="line">                        # proxy_set_header  Host  $host;</span><br><span class="line">                        # proxy_set_header  X-Real-IP  $remote_addr;  </span><br><span class="line">                        # proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">                        # proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;</span><br><span class="line">                        root &#x2F;var&#x2F;www&#x2F;hexoblog;</span><br><span class="line">                        index  index.html;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                location &#x2F;nginx_status &#123;</span><br><span class="line">                        stub_status on;</span><br><span class="line">                        access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;ngs.access.log;</span><br><span class="line">                        # allow 192.168.10.0&#x2F;24;</span><br><span class="line">                        # deny all;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                location ~ ^&#x2F;(WEB-INF)&#x2F; &#123;   </span><br><span class="line">                        deny all;   </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                # error_page  404              &#x2F;404.html;</span><br><span class="line">                # redirect server error pages to the static page &#x2F;50x.html</span><br><span class="line">                #</span><br><span class="line"></span><br><span class="line">                error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line"></span><br><span class="line">                location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">                        root   html;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">        ##</span><br><span class="line">        # Virtual Host Configs</span><br><span class="line">        ##</span><br><span class="line"></span><br><span class="line">        include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;</span><br><span class="line">        include &#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;*;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编辑完成后 esc -&gt; !wq 退出。</p>
<p>编写crontab脚本:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#this srcipt call by cron </span><br><span class="line">#will not exoprt some env var in profile or .profile</span><br><span class="line"></span><br><span class="line">rm -fr ~&#x2F;update.log</span><br><span class="line"></span><br><span class="line">#execute profile</span><br><span class="line">. &#x2F;etc&#x2F;profile</span><br><span class="line">. ~&#x2F;.profile</span><br><span class="line"></span><br><span class="line">#auto pull source code , generate and deploy to git</span><br><span class="line">. ~&#x2F;HexoBlog&#x2F;AutoUpdate.sh &gt;&gt; ~&#x2F;update.log # 根据实际位置填写</span><br><span class="line"></span><br><span class="line">#deploy</span><br><span class="line">sudo cp -r ~&#x2F;HexoBlog&#x2F;public&#x2F;* &#x2F;var&#x2F;www&#x2F;hexoblog # 注意权限</span><br></pre></td></tr></table></figure>

<p>其中  脚本 AutoUpdate.sh 是自己随着库进行同步的 ，内容如下(之所以两个脚本原因看<a href="/2017/02/24/about-crontab/" title="这里">这里</a>)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"># 如果使用cron 定时call 更新脚本 </span><br><span class="line"># 会出现 一些定义在profile 中的环境变量无法引入的情况</span><br><span class="line"># 可以单独建立一个壳脚本 添加一些必要的变量 再呼叫当前脚本 AutoUpdate.sh</span><br><span class="line">#. &#x2F;etc&#x2F;profile</span><br><span class="line">#. ~&#x2F;.profile</span><br><span class="line">#. ~&#x2F;&lt;somepath&gt;&#x2F;AutoUpdate.sh # call this srcipt</span><br><span class="line">DEFAULT_DIR&#x3D;$HOME&#x2F;HexoBlog</span><br><span class="line">echo &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; </span><br><span class="line">echo $(date +%y_%m_%d_%H_%I_%T) </span><br><span class="line">echo &quot;----------------------------------------&quot; </span><br><span class="line">echo &quot;HOME : $HOME&quot;</span><br><span class="line">echo &quot;PATH : $PATH&quot;</span><br><span class="line">echo &quot;NODE_HOME : $NODE_HOME&quot;</span><br><span class="line">echo &#96;whereis hexo&#96;</span><br><span class="line">echo &quot;----------------------------------------&quot; </span><br><span class="line">if [ $1 ] ; then        </span><br><span class="line">    echo &quot;first argument is not empty : $1&quot; </span><br><span class="line">    TAR_DIR&#x3D;$1 </span><br><span class="line">    echo &quot;use first argument as target dir : $TAR_DIR&quot; </span><br><span class="line">else</span><br><span class="line">    echo &quot;first argument is empty&quot;   </span><br><span class="line">    # use $DEFAULT_DIR as the target dir    </span><br><span class="line">    TAR_DIR&#x3D;$DEFAULT_DIR</span><br><span class="line">    echo &quot;use default dir as target dir : $TAR_DIR&quot; </span><br><span class="line">fi </span><br><span class="line">echo &quot;----------------------------------------&quot; </span><br><span class="line">if [ -d $TAR_DIR ] ; then </span><br><span class="line">    echo &quot;$TAR_DIR is a dir,try update&quot; </span><br><span class="line">    cd $TAR_DIR</span><br><span class="line">    echo &quot;++++++++++++++begin git pull++++++++++++&quot; </span><br><span class="line">    git pull </span><br><span class="line">    echo &quot;++++++++++++++begin  hexo clean+++++++++&quot;</span><br><span class="line">    hexo clean </span><br><span class="line">    echo &quot;++++++++++++++begin  hexo generate+++++++&quot;</span><br><span class="line">    hexo g </span><br><span class="line">    echo &quot;++++++++++++++begin hexo deploy+++++++++&quot;</span><br><span class="line">    hexo d </span><br><span class="line">    #echo &quot;++++++++++++++begin killall hexo++++++++&quot; </span><br><span class="line">    #killall hexo </span><br><span class="line">    #echo &quot;++++++++++++++begin hexo server+++++++++&quot;</span><br><span class="line">    #hexo server &amp;   </span><br><span class="line">else</span><br><span class="line">    echo &quot;$TAR_DIR is not a dir,do nothing&quot; </span><br><span class="line">fi</span><br><span class="line">echo &quot;----------------------------------------&quot; </span><br><span class="line">echo $(date +%y_%m_%d_%H_%I_%T) </span><br><span class="line">echo &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;</span><br></pre></td></tr></table></figure>

<p>然后  启动nginx ！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service nginx start</span><br></pre></td></tr></table></figure>

<p>完成！</p>
]]></content>
      <categories>
        <category>knowledge</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>3.SQL Server基本管理单位:区(Extend)</title>
    <url>/2017/03/21/sql-server-extend-management/</url>
    <content><![CDATA[<p>区就是一组8个页(8K),因此区是64k的块。SQL Server内部有2类区：</p>
<ul>
<li>混合区</li>
<li>统一区</li>
</ul>
<a id="more"></a>

<p>全局分配映射表（GAM: Global Allocation Map Pages） ：GAM页记录哪些些区已被使用分配。对于每个区，GAM都有一个位。如果这个位是1，表示对应的区是空闲可用的。如果这个位是0，表示对应区被统一区或混合区使用。一个GAM页可以保存64000个区的使用信息。这就是说，一个GAM可以保存近4G（64000 * 8 * 8/ 1024)数据文件的使用信息。简单来说，一个7G的数据文件会有2个GAM页。</p>
<p>共享全局分配映射表（SGAM: Shared Global Allocation Map Pages） ：SGAM页记录哪些区已被作为混合区使用并至少有一个可用的空闲页。对于每个区，SGAM都有一个位。如果这个位是1，表示对应的区作为混合区使用并至少有一个可用的空闲页。如果这个位是0，表示这个区既没被混合区使用（作为统一区），或这个区的所有页都作为混合区使用了。一个SGAM页可以保存64000个区的使用信息。这就是说，一个SGAM可以保存近4G（64000 * 8 * 8/ 1024)数据文件的使用信息。简单来说，一个7G的数据文件会有2个SGAM页。</p>
<p>GAM和SGAM页帮助数据库引擎进行区管理。分配一个区，数据库引擎查找标记1的GAM页，然后标记为0。如果那个区是作为混合区分配，它会在SGAM页把对应区的标记为1。如果那个区是作为统一区分配，那就没有必要在SGAM里修改对应位标记。找一个有空页的混合区，数据库引擎在SGAM页查找标记为1的位。如果没找到，数据文件已经满了。解除一个区分配，数据库引擎会把对应GAM页里对应位设置为1，SGAM页里对应标记设置为0。</p>
<p>在每个数据文件里，第3个页（页号2，页号从0开始）是GAM页，第4个页（页号3，页号从0开始）是SGAM页。第1个页（页号0）是文件头（file header），第2个页（页号1）是PFS（Page Free Space）页。我们可以使用DBCC PAGE命令查看GAM和SGAM页。</p>
<p><a href="http://www.cnblogs.com/wcyao/archive/2011/06/28/2092241.html" target="_blank" rel="noopener">存储引擎揭秘</a><br><a href="http://www.cnblogs.com/woodytu/tag/SQL%20Server%20%E5%AD%98%E5%82%A8/" target="_blank" rel="noopener">SQL Server 存储</a><br><a href="http://www.cnblogs.com/woodytu/p/4487310.html" target="_blank" rel="noopener">理解GAM和SGAM页</a></p>
]]></content>
      <categories>
        <category>knowledge</category>
      </categories>
      <tags>
        <tag>mssql</tag>
        <tag>performance tuning</tag>
      </tags>
  </entry>
  <entry>
    <title>sql server 锁(2)</title>
    <url>/2017/03/24/sql-server-locks-part-ii/</url>
    <content><![CDATA[<p>继续学习锁。</p>
<a id="more"></a>


<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>下载巨硬提供的<a href="https://msftdbprodsamples.codeplex.com/" target="_blank" rel="noopener">AdventureWorks</a>,下载的是<a href="https://msftdbprodsamples.codeplex.com/releases/view/125550" target="_blank" rel="noopener">2014版本</a>.是bak文件，直接恢复数据库就可以了.</p>
<p>如果比较旧的版本，例如2008R2，提供的是下载的是 mdf和ldf.可以用CRTEATE DATABASE 命令，从文件创建：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> AdventureWorks</span><br><span class="line"><span class="keyword">ON</span> (FILENAME = <span class="string">'C:\Data\AdventureWorks2008R2_Data.mdf'</span>), (FILENAME = <span class="string">'C:\Data\AdventureWorks2008R2_Log.ldf'</span>) <span class="keyword">FOR</span> ATTACH;</span><br></pre></td></tr></table></figure>

<p>创建完成后，创建需要的表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">----------------------------------------------B树表聚集索引表-------------------------------------------</span></span><br><span class="line"><span class="keyword">USE</span> [AdventureWorks]</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">IF</span> <span class="keyword">EXISTS</span> ( <span class="keyword">SELECT</span> TABLE_NAME <span class="keyword">FROM</span> INFORMATION_SCHEMA.TABLES <span class="keyword">WHERE</span> TABLE_NAME = <span class="string">'Employee_Demo_BTree'</span>)</span><br><span class="line">  <span class="keyword">DROP</span> <span class="keyword">TABLE</span> Employee_Demo_BTree</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee_Demo_BTree(</span><br><span class="line">  EmployeeID <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">  NationalIDNumber <span class="keyword">NVARCHAR</span>(<span class="number">15</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  ContactID <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  LoginID <span class="keyword">NVARCHAR</span>(<span class="number">256</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  ManagerID <span class="built_in">INT</span> <span class="literal">NULL</span>,</span><br><span class="line">  Title <span class="keyword">NVARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  BirthDate DATETIME <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  MaritalStatus <span class="keyword">NCHAR</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  Gender <span class="keyword">NCHAR</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  HireDate DATETIME <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  ModifiedDate DATETIME <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">GETDATE</span>()</span><br><span class="line">)</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="comment">--主键就已经是聚集索引了,无需再指定</span></span><br><span class="line"><span class="comment">--CREATE CLUSTERED INDEX PK_Employee_EmployeeID_Demo_BTree ON Employee_Demo_BTree(EmployeeID ASC)</span></span><br><span class="line"><span class="comment">--添加非聚集索引</span></span><br><span class="line"><span class="keyword">CREATE</span> NONCLUSTERED <span class="keyword">INDEX</span> IX_Employee_ManagerID_Demo_BTree <span class="keyword">ON</span> Employee_Demo_BTree([ManagerID] <span class="keyword">ASC</span>)</span><br><span class="line"><span class="keyword">CREATE</span> NONCLUSTERED <span class="keyword">INDEX</span> IX_Employee_ModifiedDate_Demo_BTree <span class="keyword">ON</span> Employee_Demo_BTree( [ModifiedDate] <span class="keyword">ASC</span>)</span><br><span class="line"><span class="comment">--插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> [dbo].[Employee_Demo_BTree]</span><br><span class="line">  <span class="keyword">SELECT</span> [BusinessEntityID],</span><br><span class="line">    [NationalIDNumber],</span><br><span class="line">    [BusinessEntityID]+<span class="number">100</span>,</span><br><span class="line">    [LoginID],</span><br><span class="line">    [BusinessEntityID]%<span class="number">50</span>,</span><br><span class="line">    [JobTitle],</span><br><span class="line">    [BirthDate],</span><br><span class="line">    [MaritalStatus],</span><br><span class="line">    [Gender],</span><br><span class="line">    [HireDate],</span><br><span class="line">    [ModifiedDate]</span><br><span class="line">  <span class="keyword">FROM</span> [HumanResources].[Employee]</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"></span><br><span class="line"><span class="comment">----------------------------------------------堆表非聚集索引表-------------------------------------------</span></span><br><span class="line"><span class="keyword">USE</span> [AdventureWorks]</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">IF</span> <span class="keyword">EXISTS</span>(<span class="keyword">SELECT</span> TABLE_NAME <span class="keyword">FROM</span> INFORMATION_SCHEMA.TABLES <span class="keyword">WHERE</span> TABLE_NAME = <span class="string">'Employee_Demo_Heap'</span>)</span><br><span class="line">  <span class="keyword">DROP</span> <span class="keyword">TABLE</span> Employee_Demo_Heap</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee_Demo_Heap(</span><br><span class="line">  EmployeeID <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  NationalIDNumber <span class="keyword">NVARCHAR</span>(<span class="number">15</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  ContactID <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  LoginID <span class="keyword">NVARCHAR</span>(<span class="number">256</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  ManagerID <span class="built_in">INT</span> <span class="literal">NULL</span>,</span><br><span class="line">  Title <span class="keyword">NVARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  BirthDate DATETIME <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  MaritalStatus <span class="keyword">NCHAR</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  Gender <span class="keyword">NCHAR</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  HireDate DATETIME <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  ModifiedDate DATETIME <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">GETDATE</span>()</span><br><span class="line">)</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="comment">--因为没有主键所以要指定非聚集索引</span></span><br><span class="line"><span class="keyword">CREATE</span> NONCLUSTERED <span class="keyword">INDEX</span> PK_Employee_EmployeeID_Demo_Heap <span class="keyword">ON</span> Employee_Demo_Heap( [EmployeeID] <span class="keyword">ASC</span>)</span><br><span class="line"><span class="comment">--添加非聚集索引</span></span><br><span class="line"><span class="keyword">CREATE</span> NONCLUSTERED <span class="keyword">INDEX</span> IX_Employee_ManagerID_Demo_Heap <span class="keyword">ON</span> Employee_Demo_BTree([ManagerID] <span class="keyword">ASC</span>)</span><br><span class="line"><span class="keyword">CREATE</span> NONCLUSTERED <span class="keyword">INDEX</span> IX_Employee_ModifiedDate_Demo_Heap <span class="keyword">ON</span> Employee_Demo_BTree( [ModifiedDate] <span class="keyword">ASC</span>)</span><br><span class="line"><span class="comment">--插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> [dbo].[Employee_Demo_Heap]</span><br><span class="line">  <span class="keyword">SELECT</span> [BusinessEntityID],</span><br><span class="line">    [NationalIDNumber],</span><br><span class="line">    [BusinessEntityID]+<span class="number">100</span>,</span><br><span class="line">    [LoginID],</span><br><span class="line">    [BusinessEntityID]%<span class="number">50</span>,</span><br><span class="line">    [JobTitle],</span><br><span class="line">    [BirthDate],</span><br><span class="line">    [MaritalStatus],</span><br><span class="line">    [Gender],</span><br><span class="line">    [HireDate],</span><br><span class="line">    [ModifiedDate]</span><br><span class="line">  <span class="keyword">FROM</span> [HumanResources].[Employee]</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="监视锁申请、持有和释放"><a href="#监视锁申请、持有和释放" class="headerlink" title="监视锁申请、持有和释放"></a>监视锁申请、持有和释放</h1><p>该语句可以查看当前锁申请、持有等情况：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">     <span class="keyword">GETDATE</span>()<span class="keyword">AS</span> <span class="string">'current_time'</span> </span><br><span class="line">	 <span class="comment">--回话id</span></span><br><span class="line">	 ,<span class="keyword">CASE</span> es.session_id</span><br><span class="line">        <span class="keyword">WHEN</span> <span class="number">-2</span> <span class="keyword">THEN</span> <span class="string">'Orphaned Distributed Transaction'</span></span><br><span class="line">        <span class="keyword">WHEN</span> <span class="number">-3</span> <span class="keyword">THEN</span> <span class="string">'Deferred Recovery Transaction'</span></span><br><span class="line">		<span class="keyword">ELSE</span> es.session_id</span><br><span class="line">	 <span class="keyword">END</span> <span class="keyword">AS</span> spid</span><br><span class="line">	 <span class="comment">--锁资源情况</span></span><br><span class="line">     ,db_name(sp.dbid)<span class="keyword">AS</span> database_name </span><br><span class="line">	 ,<span class="keyword">CASE</span> </span><br><span class="line">       <span class="keyword">WHEN</span> tl.resource_type = <span class="string">'OBJECT'</span></span><br><span class="line">           <span class="keyword">THEN</span> OBJECT_NAME(tl.resource_associated_entity_id)</span><br><span class="line">       <span class="keyword">WHEN</span> tl.resource_type <span class="keyword">IN</span> (<span class="string">'KEY'</span>, <span class="string">'PAGE'</span>, <span class="string">'RID'</span>)</span><br><span class="line">            <span class="keyword">THEN</span> (<span class="keyword">SELECT</span> object_name(object_id)</span><br><span class="line">                <span class="keyword">FROM</span> sys.partitions <span class="keyword">AS</span> ps1</span><br><span class="line">                <span class="keyword">WHERE</span> ps1.hobt_id = tl.resource_associated_entity_id)</span><br><span class="line">       <span class="keyword">ELSE</span> <span class="string">''</span> </span><br><span class="line">     <span class="keyword">END</span> <span class="keyword">AS</span> lock_object_name</span><br><span class="line">	 ,tl.resource_type <span class="keyword">AS</span> lock_resource </span><br><span class="line">     ,tl.request_mode <span class="keyword">AS</span> lock_mode </span><br><span class="line">     ,tl.resource_associated_entity_id <span class="keyword">AS</span> lock_resource_id</span><br><span class="line">	 ,tl.resource_description <span class="keyword">AS</span> lock_resource_info</span><br><span class="line">	 ,tl.request_status <span class="keyword">AS</span> lock_status </span><br><span class="line">	 <span class="comment">--回话信息</span></span><br><span class="line">	 <span class="comment">--,es.status AS session_status     </span></span><br><span class="line">     <span class="comment">--,es.host_name</span></span><br><span class="line">     <span class="comment">--,es.login_time</span></span><br><span class="line">     <span class="comment">--,es.login_name</span></span><br><span class="line">     <span class="comment">--,es.program_name</span></span><br><span class="line">	 <span class="comment">--,CONVERT(float, ROUND((ISNULL(es.cpu_time, 0.0)/1000.00), 0))AS  cpu_time</span></span><br><span class="line">     <span class="comment">--,CONVERT(float, ROUND((ISNULL(es.lock_timeout, 0.0)/1000.00), 0))AS lock_timeout</span></span><br><span class="line">	 <span class="comment">--事务信息</span></span><br><span class="line">	 ,tat.name <span class="keyword">AS</span> trans_name</span><br><span class="line">	 ,<span class="keyword">CASE</span> tst.is_user_transaction</span><br><span class="line">		<span class="keyword">WHEN</span> <span class="number">0</span></span><br><span class="line">			<span class="keyword">THEN</span> <span class="string">'system'</span></span><br><span class="line">		<span class="keyword">WHEN</span> <span class="number">1</span></span><br><span class="line">			<span class="keyword">THEN</span> <span class="string">'user'</span></span><br><span class="line">		<span class="keyword">END</span> <span class="keyword">AS</span> trans_type</span><br><span class="line">	 ,<span class="keyword">substring</span>((<span class="keyword">SELECT</span> <span class="built_in">text</span></span><br><span class="line">        <span class="keyword">FROM</span> sys.dm_exec_sql_text(sp.sql_handle)), <span class="number">1</span>, <span class="number">128</span>) <span class="keyword">AS</span> sql_text </span><br><span class="line">	 ,<span class="keyword">CASE</span> er.transaction_isolation_level</span><br><span class="line">       <span class="keyword">WHEN</span> <span class="number">0</span> <span class="keyword">THEN</span> <span class="string">'Unspecified'</span></span><br><span class="line">       <span class="keyword">WHEN</span> <span class="number">1</span> <span class="keyword">THEN</span> <span class="string">'Read Uncomitted'</span></span><br><span class="line">       <span class="keyword">WHEN</span> <span class="number">2</span> <span class="keyword">THEN</span> <span class="string">'Read Committed'</span></span><br><span class="line">       <span class="keyword">WHEN</span> <span class="number">3</span> <span class="keyword">THEN</span> <span class="string">'Repeatable'</span></span><br><span class="line">       <span class="keyword">WHEN</span> <span class="number">4</span> <span class="keyword">THEN</span> <span class="string">'Serializable'</span></span><br><span class="line">       <span class="keyword">WHEN</span> <span class="number">5</span> <span class="keyword">THEN</span> <span class="string">'Snapshot'</span></span><br><span class="line">       <span class="keyword">ELSE</span> <span class="string">''</span></span><br><span class="line">     <span class="keyword">END</span> transaction_isolation_level</span><br><span class="line">	 <span class="comment">--连接信息</span></span><br><span class="line">     <span class="comment">--,er.connection_id</span></span><br><span class="line">     ,<span class="keyword">CASE</span> er.blocking_session_id</span><br><span class="line">       <span class="keyword">WHEN</span> <span class="number">-2</span> <span class="keyword">THEN</span> <span class="string">'Orphaned Distributed Transaction'</span></span><br><span class="line">       <span class="keyword">WHEN</span> <span class="number">-3</span> <span class="keyword">THEN</span> <span class="string">'Deferred Recovery Transaction'</span></span><br><span class="line">       <span class="keyword">WHEN</span> <span class="number">-4</span> <span class="keyword">THEN</span> <span class="string">'Latch Owner Not Determined'</span></span><br><span class="line">       <span class="keyword">ELSE</span> er.blocking_session_id</span><br><span class="line">     <span class="keyword">END</span> <span class="keyword">AS</span> blocking_by</span><br><span class="line">     ,er.wait_type</span><br><span class="line">     <span class="comment">--,CONVERT(float, ROUND((ISNULL(er.wait_time, 0.0)/1000.00), 0))AS wait_time</span></span><br><span class="line">     <span class="comment">--,er.percent_complete</span></span><br><span class="line">     <span class="comment">--,er.estimated_completion_time</span></span><br><span class="line">     <span class="comment">--,CONVERT(float, ROUND((ISNULL(er.total_elapsed_time, 0.0)/1000.00), 0))AS total_elapsed_time</span></span><br><span class="line">     <span class="comment">--,ec.connect_time</span></span><br><span class="line">     <span class="comment">--,ec.net_transport</span></span><br><span class="line">     <span class="comment">--,ec.client_net_address</span></span><br><span class="line"><span class="keyword">FROM</span>  master.sys.dm_exec_sessions <span class="keyword">AS</span> es</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> master.sys.sysprocesses <span class="keyword">AS</span> sp </span><br><span class="line"><span class="keyword">ON</span> sp.spid = es.session_id</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> master.sys.dm_exec_connections <span class="keyword">AS</span> ec </span><br><span class="line"><span class="keyword">ON</span> ec.session_id = es.session_id</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> master.sys.dm_exec_requests <span class="keyword">AS</span> er </span><br><span class="line"><span class="keyword">ON</span> er.session_id = es.session_id</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> master.sys.dm_tran_locks <span class="keyword">AS</span> tl </span><br><span class="line"><span class="keyword">ON</span> tl.request_session_id = es.session_id		</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> master.sys.dm_tran_session_transactions <span class="keyword">AS</span> tst </span><br><span class="line"><span class="keyword">ON</span> es.session_id = tst.session_id</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> master.sys.dm_tran_active_transactions <span class="keyword">AS</span> tat </span><br><span class="line"><span class="keyword">ON</span> tst.transaction_id = tat.transaction_id</span><br><span class="line"><span class="keyword">WHERE</span> spid &lt;&gt; @@spid<span class="comment">/* IGNORE CURRENT SESSION */</span></span><br><span class="line"><span class="keyword">AND</span> sp.dbid = db_id()<span class="comment">/* CURRENT DB TO MONITOR */</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> spid,database_name,lock_object_name,lock_resource</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="实际查询中锁的申请与释放"><a href="#实际查询中锁的申请与释放" class="headerlink" title="实际查询中锁的申请与释放"></a>实际查询中锁的申请与释放</h1><h2 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h2><h3 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">--select动作要申请的锁(1)</span></span><br><span class="line"><span class="comment">--聚集表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> REPEATABLE <span class="keyword">READ</span> </span><br><span class="line"><span class="comment">--REPEATABLE READ  会一直持有S锁 直到事务结束</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">STATISTICS</span> PROFILE <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN select_from_btree_1</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">[EmployeeID],</span><br><span class="line">[LoginID],</span><br><span class="line">[Title]</span><br><span class="line"><span class="keyword">FROM</span> [dbo].[Employee_Demo_BTree]</span><br><span class="line"><span class="keyword">WHERE</span> [EmployeeID]=<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--COMMIT TRAN</span></span><br><span class="line"><span class="comment">--ROLLBACK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--1-- DATABASE,,S,	</span></span><br><span class="line"><span class="comment">--2-- Employee_Demo_BTree,OBJECT,IS  </span></span><br><span class="line"><span class="comment">--3-- Employee_Demo_BTree,KEY,S,(98ec012aa510)</span></span><br><span class="line"><span class="comment">--4-- Employee_Demo_BTree,PAGE,IS,1:24345 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">--1.因为连接正在访问数据库[AdventureWorks],所以在数据库一级加了一个共享锁,以防止别人将数据库删除</span></span><br><span class="line"><span class="comment">--2.因为正在访问表格[Employee_Demo_BTree]，所以在表格上加了一个意向共享锁,以防止别人修改表的定义</span></span><br><span class="line"><span class="comment">--3.查询有1条记录返回,所以在这1条记录所在的聚集索引键上,持有一个共享锁。</span></span><br><span class="line"><span class="comment">--4.在这个聚集索引键所在的页(因为是聚集索引,因此键所在的叶子是数据页)上持有一个意向共享锁</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="实验2"><a href="#实验2" class="headerlink" title="实验2"></a>实验2</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">--select动作要申请的锁(2)</span></span><br><span class="line"><span class="comment">--堆表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> REPEATABLE <span class="keyword">READ</span> </span><br><span class="line"><span class="comment">--REPEATABLE READ  会一直持有S锁 直到事务结束</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">STATISTICS</span> PROFILE <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN select_from_heap_2</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">[EmployeeID],</span><br><span class="line">[LoginID],</span><br><span class="line">[Title]</span><br><span class="line"><span class="keyword">FROM</span> [dbo].[Employee_Demo_Heap]</span><br><span class="line"><span class="keyword">WHERE</span> [EmployeeID]=<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--COMMIT TRAN</span></span><br><span class="line"><span class="comment">--ROLLBACK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--1-- ,DATABASE,S,</span></span><br><span class="line"><span class="comment">--2-- Employee_Demo_Heap,OBJECT,IS,</span></span><br><span class="line"><span class="comment">--3-- Employee_Demo_Heap,KEY,S,(99944d58347a) </span></span><br><span class="line"><span class="comment">--4-- Employee_Demo_Heap,RID,S,1:24344:2</span></span><br><span class="line"><span class="comment">--5-- Employee_Demo_Heap,PAGE,IS,1:24353 </span></span><br><span class="line"><span class="comment">--6-- Employee_Demo_Heap,PAGE,IS,1:24344 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">--1.因为连接正在访问数据库[AdventureWorks],所以在数据库一级加了一个共享锁,以防止别人将数据库删除</span></span><br><span class="line"><span class="comment">--2.因为正在访问表格[Employee_Demo_Heap]，所以在表格上加了一个意向共享锁,以防止别人修改表的定义</span></span><br><span class="line"><span class="comment">--3-4.通过非聚集键找到数据RID,再通过RID查找到数据（即书签查找  bookmark lookup）,因此对这个非聚集索引键和数据的RID分别持有一个共享锁</span></span><br><span class="line"><span class="comment">--5-6.Key和RID(数据页)所在的页面上分别持有一个IS锁。   </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="实验3"><a href="#实验3" class="headerlink" title="实验3"></a>实验3</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">--select动作要申请的锁(3)</span></span><br><span class="line"><span class="comment">--聚集表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> REPEATABLE <span class="keyword">READ</span></span><br><span class="line"><span class="comment">--REPEATABLE READ  会一直持有S锁 直到事务结束</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">STATISTICS</span> PROFILE <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN select_from_btree_3</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> [EmployeeID],[LoginID],[Title]</span><br><span class="line"><span class="keyword">FROM</span> [dbo].[Employee_Demo_BTree] </span><br><span class="line"><span class="keyword">WHERE</span> [EmployeeID] <span class="keyword">IN</span>(<span class="number">3</span>,<span class="number">30</span>,<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--COMMIT TRAN</span></span><br><span class="line"><span class="comment">--ROLLBACK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--1-- ,DATABASE,S,</span></span><br><span class="line"><span class="comment">--2-- Employee_Demo_BTree,OBJECT,IS,    </span></span><br><span class="line"><span class="comment">--3-- Employee_Demo_BTree,KEY,S,(98ec012aa510)   </span></span><br><span class="line"><span class="comment">--4-- Employee_Demo_BTree,KEY,S,(af5579654878)    </span></span><br><span class="line"><span class="comment">--5-- Employee_Demo_BTree,KEY,S,(8034b699f2c9)    </span></span><br><span class="line"><span class="comment">--6-- Employee_Demo_BTree,PAGE,IS,1:24183           </span></span><br><span class="line"><span class="comment">--7-- Employee_Demo_BTree,PAGE,IS,1:24345 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">--1.因为连接正在访问数据库[AdventureWorks],所以在数据库一级加了一个共享锁,以防止别人将数据库删除</span></span><br><span class="line"><span class="comment">--2.因为正在访问表格[Employee_Demo_BTree]，所以在表格上加了一个意向共享锁,以防止别人修改表的定义</span></span><br><span class="line"><span class="comment">--3-5.查询有3条记录返回,所以在这3条记录所在的聚集索引键上,分别持有一个共享锁。</span></span><br><span class="line"><span class="comment">--6-7.在这3个数据分布在2个页上,在两个页上分别持有一个意向共享锁  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="实验4"><a href="#实验4" class="headerlink" title="实验4"></a>实验4</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--select动作要申请的锁(4)</span></span><br><span class="line"><span class="comment">--堆表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> REPEATABLE <span class="keyword">READ</span></span><br><span class="line"><span class="comment">--REPEATABLE READ  会一直持有S锁 直到事务结束</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">STATISTICS</span> PROFILE <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">STATISTICS</span> IO <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN select_from_heap_4</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> [EmployeeID],[LoginID],[Title]</span><br><span class="line"><span class="keyword">FROM</span> [dbo].[Employee_Demo_Heap] <span class="comment">--with (index (PK_Employee_EmployeeID_Demo_Heap))</span></span><br><span class="line"><span class="keyword">WHERE</span> [EmployeeID] <span class="keyword">IN</span>(<span class="number">3</span>,<span class="number">30</span>,<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--COMMIT TRAN</span></span><br><span class="line"><span class="comment">--ROLLBACK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--1-- ,DATABASE,S,                 </span></span><br><span class="line"><span class="comment">--2-- Employee_Demo_Heap,OBJECT,IS,                 </span></span><br><span class="line"><span class="comment">--3-- Employee_Demo_Heap,PAGE,IS,1:24360           </span></span><br><span class="line"><span class="comment">--4-- Employee_Demo_Heap,PAGE,IS,1:24359         </span></span><br><span class="line"><span class="comment">--5-- Employee_Demo_Heap,PAGE,IS,1:24358          </span></span><br><span class="line"><span class="comment">--6-- Employee_Demo_Heap,PAGE,IS,1:24357          </span></span><br><span class="line"><span class="comment">--7-- Employee_Demo_Heap,PAGE,IS,1:24356          </span></span><br><span class="line"><span class="comment">--8-- Employee_Demo_Heap,PAGE,IS,1:24355          </span></span><br><span class="line"><span class="comment">--9-- Employee_Demo_Heap,PAGE,IS,1:24344          </span></span><br><span class="line"><span class="comment">--10--Employee_Demo_Heap,RID,S,1:24344:29         </span></span><br><span class="line"><span class="comment">--11--Employee_Demo_Heap,RID,S,1:24358:16       </span></span><br><span class="line"><span class="comment">--12--Employee_Demo_Heap,RID,S,1:24344:2       </span></span><br><span class="line"></span><br><span class="line"><span class="comment">--1.因为连接正在访问数据库[AdventureWorks],所以在数据库一级加了一个共享锁,以防止别人将数据库删除</span></span><br><span class="line"><span class="comment">--2-9.查询计划分析后发现 Index Seek（9次逻辑读 --with (index (PK_Employee_EmployeeID_Demo_Heap))）开销比 Table Scan(7次逻辑读) 大,因此决定使用 Table Scan,因此在所有页面上添加IS</span></span><br><span class="line"><span class="comment">--10-12 读取到的数据RID加S锁</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="实验5"><a href="#实验5" class="headerlink" title="实验5"></a>实验5</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">--会话1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN update_heap_5</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> [dbo].[Employee_Demo_Heap]</span><br><span class="line"><span class="keyword">SET</span> [Title]=<span class="string">'aaa'</span></span><br><span class="line"><span class="keyword">WHERE</span> [EmployeeID]=<span class="number">70</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--COMMIT TRAN</span></span><br><span class="line"><span class="comment">--ROLLBACK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--会话2</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> REPEATABLE <span class="keyword">READ</span> </span><br><span class="line"><span class="comment">--REPEATABLE READ  会一直持有S锁 直到事务结束</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">STATISTICS</span> PROFILE <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">STATISTICS</span> IO <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN select_from_heap_5</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> [EmployeeID],[LoginID],[Title]</span><br><span class="line"><span class="keyword">FROM</span> [dbo].[Employee_Demo_Heap] </span><br><span class="line"><span class="keyword">WHERE</span> [EmployeeID] <span class="keyword">IN</span>(<span class="number">3</span>,<span class="number">80</span>,<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--COMMIT TRAN</span></span><br><span class="line"><span class="comment">--ROLLBACK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--,DATABASE,S,                  </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,OBJECT,IS,                </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,PAGE,IS,1:24344           </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,PAGE,IS,1:24360           </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,PAGE,IS,1:24359           </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,PAGE,IS,1:24358           </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,PAGE,IS,1:24357           </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,PAGE,IS,1:24356            </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,PAGE,IS,1:24355            </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,RID,S,1:24355:32        </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,RID,S,1:24358:16        </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,RID,S,1:24344:2   </span></span><br><span class="line"></span><br><span class="line"><span class="comment">--Table Scan 时候会逐个获取 RID 的 S 锁 但是 Update 持有了 ID=70的 X锁</span></span><br><span class="line"><span class="comment">--因此select 会被阻塞</span></span><br><span class="line"><span class="comment">--但是当获取到ID=70的锁后 发现不需要返回该数据 </span></span><br><span class="line"><span class="comment">--因此会释放ID-70的数据的S锁</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="实验6"><a href="#实验6" class="headerlink" title="实验6"></a>实验6</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">--会话1</span></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN update_heap_6</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> [dbo].[Employee_Demo_BTree]</span><br><span class="line"><span class="keyword">SET</span> [Title]=<span class="string">'aaa'</span></span><br><span class="line"><span class="keyword">WHERE</span> [EmployeeID]=<span class="number">70</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--COMMIT TRAN</span></span><br><span class="line"><span class="comment">--ROLLBACK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--会话2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> REPEATABLE <span class="keyword">READ</span> </span><br><span class="line"><span class="comment">--REPEATABLE READ  会一直持有S锁 直到事务结束</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">STATISTICS</span> PROFILE <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">STATISTICS</span> IO <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN select_from_beetree_6</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> [EmployeeID],[LoginID],[Title]</span><br><span class="line"><span class="keyword">FROM</span> [dbo].[Employee_Demo_BTree] </span><br><span class="line"><span class="keyword">WHERE</span> [EmployeeID] <span class="keyword">IN</span>(<span class="number">3</span>,<span class="number">80</span>,<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--COMMIT TRAN</span></span><br><span class="line"><span class="comment">--ROLLBACK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--使用Clustered Index Seek 不会扫描到 不需要的数据（例如ID=70） 因此不会被Update 阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--,DATABASE,S,                  </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,KEY,S,(98ec012aa510)    </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,KEY,S,(af5579654878)    </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,KEY,S,(d2e40430031e)  </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,OBJECT,IS,                 </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,PAGE,IS,1:24183          </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,PAGE,IS,1:24178          </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,PAGE,IS,1:24345          </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>查询在运行过程中，会对每一条读到的记录或键值加共享锁。如果记录不用返回。那锁就会被释放。如果记录需要被返回，则视隔离级别而定，如果是“已提交读”，则也释放否则，不释放</li>
<li>对每一个使用到的索引，SQL也会对上面的键值加共享锁</li>
<li>对每个读过的页面，SQL会加一个意向锁</li>
<li>查询需要扫描页面和记录越多，锁的数目也会越多。查询用到的索引越多，锁的数目也会越多</li>
</ul>
<p>当然，这些对于“已提交读”以上隔离级别而言。如果使用“未提交读”，SQL就不会申请这些共享锁阻塞也不会发生</p>
<p>避免阻塞采取的方法</p>
<ul>
<li>尽量返回少的记录集，返回的结果越多，需要的锁也就越多</li>
<li>如果返回结果集只是表格所有记录的一小部分，要尽量使用index seek，避免全表扫描这种执行计划</li>
<li>可能的话，设计好合适的索引，避免SQL通过多个索引才找到数据</li>
</ul>
<h2 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h2><h3 id="实验1-1"><a href="#实验1-1" class="headerlink" title="实验1"></a>实验1</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--UPDATE动作要申请的锁(1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">USE</span> [AdventureWorks] </span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> REPEATABLE <span class="keyword">READ</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN update_1</span><br><span class="line"><span class="keyword">UPDATE</span> [dbo].[Employee_Demo_Heap]</span><br><span class="line"><span class="keyword">SET</span> [Title]=<span class="string">'changehea1213412p'</span></span><br><span class="line"><span class="keyword">WHERE</span> [EmployeeID] <span class="keyword">IN</span>(<span class="number">3</span>,<span class="number">30</span>,<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--COMMIT TRAN</span></span><br><span class="line"><span class="comment">--ROLLBACK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--从这个例子可以看出，如果update借助了哪个索引，这个索引的键值上就会有U锁,没有用到的索引上没有锁。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--,DATABASE,S, </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,OBJECT,IX,                   </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,KEY,U,(76bc6173e51d)   </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,KEY,U,(ec8f0458157e)    </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,KEY,U,(8d9ce4e03eca) </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,PAGE,IU,1:24190          </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,RID,X,1:24188:29       </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,RID,X,1:24374:16        </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,RID,X,1:24188:2                                               </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,PAGE,IX,1:24188            </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,PAGE,IX,1:24374 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">--在非聚集索引上申请了3个U锁这 通过非聚集索引PK_Employee_EmployeeID_Demo_Heap（index_id是2）找到了这3条记录</span></span><br><span class="line"><span class="comment">--在RID上申请了3个X锁。数据RID上有了修改，所以RID上加的是X锁，其他索引上没有加锁</span></span><br><span class="line"><span class="comment">--对于查询涉及的页面，SQL加了IU锁意向更新锁，修改发生的页面，SQL加了IX锁 意向排他锁 （先查询再修改）锁key 锁索引键值 因为修改的列没有被索引  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="实验2-1"><a href="#实验2-1" class="headerlink" title="实验2"></a>实验2</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">--UPDATE动作要申请的锁(2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--DROP INDEX [Employee_Demo_BTree_Title]  ON [AdventureWorks].[dbo].[Employee_Demo_BTree]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">USE</span> [AdventureWorks]</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> REPEATABLE <span class="keyword">READ</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN update_2</span><br><span class="line"><span class="keyword">UPDATE</span> [dbo].[Employee_Demo_BTree]</span><br><span class="line"><span class="keyword">SET</span> [Title]=<span class="string">'changeheap'</span></span><br><span class="line"><span class="keyword">WHERE</span> [EmployeeID] <span class="keyword">IN</span>(<span class="number">3</span>,<span class="number">30</span>,<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--COMMIT TRAN</span></span><br><span class="line"><span class="comment">--ROLLBACK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--,DATABASE,S,                 </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,KEY,X,(98ec012aa510)   </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,KEY,X,(af5579654878)   </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,KEY,X,(8034b699f2c9)    </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,OBJECT,IX,                 </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,PAGE,IX,1:24183           </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,PAGE,IX,1:24361 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="实验3-1"><a href="#实验3-1" class="headerlink" title="实验3"></a>实验3</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">--UPDATE动作要申请的锁(3)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--如果修改的列被一个索引使用到了，会是什么情况呢？为了完成这个测试，先在Employee_Demo_BTree</span></span><br><span class="line"><span class="comment">--上建一个会被修改的索引</span></span><br><span class="line"><span class="comment">--CREATE NONCLUSTERED INDEX [Employee_Demo_BTree_Title] ON [AdventureWorks].[dbo].[Employee_Demo_BTree]([Title] ASC)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--再运行下面语句</span></span><br><span class="line"><span class="keyword">USE</span> [AdventureWorks]</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> REPEATABLE <span class="keyword">READ</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN update_3</span><br><span class="line"><span class="keyword">UPDATE</span> [dbo].[Employee_Demo_BTree]</span><br><span class="line"><span class="keyword">SET</span> [Title]=<span class="string">'changeheap'</span></span><br><span class="line"><span class="keyword">WHERE</span> [EmployeeID] <span class="keyword">IN</span>(<span class="number">3</span>,<span class="number">30</span>,<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--COMMIT TRAN</span></span><br><span class="line"><span class="comment">--ROLLBACK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--,DATABASE,S,    </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,OBJECT,IX,               </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,KEY,X,(e1ec96b5ebdf)   </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,KEY,X,(3257b8d72bb6)    </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,KEY,X,(dfeed147c0d9)   </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,KEY,X,(7cf149949204)    </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,KEY,X,(e857a9082db1)   </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,KEY,X,(c73666f49700)   </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,KEY,X,(98ec012aa510)   </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,KEY,X,(af5579654878)  </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,KEY,X,(8034b699f2c9)</span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,PAGE,IX,1:24183           </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,PAGE,IX,1:24361          </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,PAGE,IX,1:24382           </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,PAGE,IX,1:24379           </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,PAGE,IX,1:24377       </span></span><br><span class="line"></span><br><span class="line"><span class="comment">--语句利用聚集索引找到要修改的3条记录.但是我们看到有9个键上有X锁。</span></span><br><span class="line"><span class="comment">--很有意思：PK_Employee_EmployeeID_Demo_BTree（index_id=1）聚集索引，也是数据存放的地方。</span></span><br><span class="line"><span class="comment">--UPDATE_2做的update语句没有改到他的索引列，他只需把Title这个列的值改掉。所以在index1上，只申请3个X锁，每条记录一个</span></span><br><span class="line"><span class="comment">--但是表格在Title上面有一个非聚集索引IX_Employee_ManagerID_Demo_BTree（index_id=5）,并且Title是第一列。他被修改后，原来的索引键值就要被删除掉，并且插入新的键值。</span></span><br><span class="line"><span class="comment">--所以在index_id=5 上要申请6个X锁，老的键值3个，新的键值3个</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>对于update语句，可以简单理解为SQL先做查询，把需要修改的记录给找到，然后在这个记录上做修改。找记录的动作要加S锁，找到修改的记录后加U锁，再将U锁升级为X锁。加锁的位置是 RID(堆表)或者CLUSTER_INDEX(聚集表)</p>
<p>想降低一个update语句被别人阻塞住的几率，除了注意他的查询部分之外，还要做的事情有：</p>
<ul>
<li>尽量修改少的记录集。修改的记录越多，需要的锁也就越多</li>
<li>尽量减少无谓的索引。索引的数目越多，需要的锁也可能越多</li>
<li>但是也要严格避免表扫描的发生。如果只是修改表格记录的一小部分，要尽量使用index seek索引查找避免全表扫描这种执行计划</li>
</ul>
<h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><h3 id="实验1-2"><a href="#实验1-2" class="headerlink" title="实验1"></a>实验1</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">--delete动作要申请的锁（1）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">USE</span> [AdventureWorks]</span><br><span class="line"><span class="keyword">BEGIN</span> TRAN delete_1</span><br><span class="line"><span class="keyword">DELETE</span> [dbo].[Employee_Demo_BTree]</span><br><span class="line"><span class="keyword">WHERE</span> [LoginID]=<span class="string">'adventure-works\kim1'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--COMMIT TRAN</span></span><br><span class="line"><span class="comment">--ROLLBACK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--,DATABASE,S,                                                                                                        </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,OBJECT,IX,                </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,KEY,X,(a8fc9de67ccb)   </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,KEY,X,(ad818e966dc0)   </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,KEY,X,(38fd2d9689b5)            </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,PAGE,IX,1:24361           </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,PAGE,IX,1:24365  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">--可以看到delete语句在聚集索引（index_id=1）和两个非聚集索引（index_id=2和3）上各申请了一个X锁在</span></span><br><span class="line"><span class="comment">--所在的页面上申请了一个IX锁</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="实验2-2"><a href="#实验2-2" class="headerlink" title="实验2"></a>实验2</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">--delete动作要申请的锁（2）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">USE</span> [AdventureWorks]</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> REPEATABLE <span class="keyword">READ</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN  delete_2</span><br><span class="line"><span class="keyword">DELETE</span> [dbo].[Employee_Demo_Heap]</span><br><span class="line"><span class="keyword">WHERE</span> [LoginID]=<span class="string">'adventure-works\tete0'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--COMMIT TRAN</span></span><br><span class="line"><span class="comment">--ROLLBACK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--,DATABASE,S,                 </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,KEY,X,(a9c8ddfb091b)    </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,KEY,X,(85b6a54957a8)    </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,KEY,X,(c8fabd8e786b)     </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,OBJECT,IX,                 </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,PAGE,IX,1:24360           </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,PAGE,IX,1:24369           </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,PAGE,IU,1:24188          </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,PAGE,IX,1:24376          </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,PAGE,IU,1:24375            </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,PAGE,IU,1:24374           </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,PAGE,IU,1:24373          </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,PAGE,IU,1:24372           </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,PAGE,IU,1:24371          </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,PAGE,IX,1:24190          </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,RID,X,1:24376:2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--可以看到delete语句在3个非聚集索引（index_id=2、3、4）上各申请了一个X锁。</span></span><br><span class="line"><span class="comment">--在所在的页面上申请了一个IX锁。</span></span><br><span class="line"><span class="comment">--在修改发生的heap数据页面上，申请了一个IX锁，相应的RID上（真正的数据记录）申请了一个X锁。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--如果使用repeatable read这个级别运行上面的delete命令，就能看出好像做select的时候一样，做delete的时候SQL也需要先找到要删除的记录。</span></span><br><span class="line"><span class="comment">--在找的过程中也会加锁,描过的页面申请IU锁</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>delete的过程是先找到记录，然后做删除。可以理解为先是一个select,然后是delete.所以,如果有合适的索引,第一步申请的锁就会比较少,不用表扫描</li>
<li>delete不但是把数据行本身删除,还要删除所有相关的索引键.所以一张表上索引数目越多锁的数目就会越多,也就越容易发生阻塞</li>
</ul>
<p>为了防止阻塞,我们既不能绝对地不建索引,也不能随随便便地建立很多索引,而是要建立对查找有利的索引.对于没有使用到的索引,还是去掉比较好</p>
<h2 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h2><h3 id="实验1-3"><a href="#实验1-3" class="headerlink" title="实验1"></a>实验1</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">--INSERT 要申请的锁（1）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">USE</span> [AdventureWorks]</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> REPEATABLE <span class="keyword">READ</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> [dbo].[Employee_Demo_Heap]</span><br><span class="line">        ( [EmployeeID] ,</span><br><span class="line">          [NationalIDNumber] ,</span><br><span class="line">          [ContactID] ,</span><br><span class="line">          [LoginID] ,</span><br><span class="line">          [ManagerID] ,</span><br><span class="line">          [Title] ,</span><br><span class="line">          [BirthDate] ,</span><br><span class="line">          [MaritalStatus] ,</span><br><span class="line">          [Gender] ,</span><br><span class="line">          [HireDate] ,</span><br><span class="line">          [ModifiedDate]</span><br><span class="line">        )</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="number">501</span>,</span><br><span class="line"><span class="number">480168528</span>,</span><br><span class="line"><span class="number">1009</span>,</span><br><span class="line"><span class="string">'adventure-works\thierry0'</span>,</span><br><span class="line"><span class="number">263</span>,</span><br><span class="line"><span class="string">'Tool Desinger'</span>,</span><br><span class="line"><span class="string">'1949-08-29 00:00:00.000'</span>,</span><br><span class="line"><span class="string">'M'</span>,</span><br><span class="line"><span class="string">'M'</span>,</span><br><span class="line"><span class="string">'1998-01-11 00:00:00.000'</span>,</span><br><span class="line"><span class="string">'2004-07-31 00:00:00.000'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--COMMIT TRAN</span></span><br><span class="line"><span class="comment">--ROLLBACK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--,DATABASE,S,    </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,OBJECT,IX,                 </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,KEY,X,(2b4f69bdcc15)   </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,KEY,X,(82704d2b820e)    </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,KEY,X,(6317a951a3c2)            </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,PAGE,IX,1:24190           </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,PAGE,IX,1:24360          </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,PAGE,IX,1:24369            </span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,RID,X,1:24376:9</span></span><br><span class="line"><span class="comment">--Employee_Demo_Heap,PAGE,IX,1:24376   </span></span><br><span class="line"></span><br><span class="line"><span class="comment">--（1）数据库上的S锁（resource_type=DATABASE）</span></span><br><span class="line"><span class="comment">--（2）表上的IX锁（resource_type=OBJECT）</span></span><br><span class="line"><span class="comment">--（3）每个索引上都要插入一条新数据，所以有一个key上的X锁</span></span><br><span class="line"><span class="comment">--（4）在每个索引上发生变化的那个页面，申请了一个IX锁（resource_type=PAGE）</span></span><br><span class="line"><span class="comment">--（5）RID锁。因为真正的数据不是放在索引上，而是放在heap数据页面上</span></span><br><span class="line"><span class="comment">-- (6) RID 所在页面（24376）：IX锁</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="实验2-3"><a href="#实验2-3" class="headerlink" title="实验2"></a>实验2</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">--INSERT 要申请的锁（2）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">USE</span> [AdventureWorks]</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> REPEATABLE <span class="keyword">READ</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> [dbo].[Employee_Demo_BTree]</span><br><span class="line">        ( [EmployeeID] ,</span><br><span class="line">          [NationalIDNumber] ,</span><br><span class="line">          [ContactID] ,</span><br><span class="line">          [LoginID] ,</span><br><span class="line">          [ManagerID] ,</span><br><span class="line">          [Title] ,</span><br><span class="line">          [BirthDate] ,</span><br><span class="line">          [MaritalStatus] ,</span><br><span class="line">          [Gender] ,</span><br><span class="line">          [HireDate] ,</span><br><span class="line">          [ModifiedDate]</span><br><span class="line">        )</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="number">501</span>,</span><br><span class="line"><span class="number">480168528</span>,</span><br><span class="line"><span class="number">1009</span>,</span><br><span class="line"><span class="string">'adventure-works\thierry0'</span>,</span><br><span class="line"><span class="number">263</span>,</span><br><span class="line"><span class="string">'Tool Desinger'</span>,</span><br><span class="line"><span class="string">'1949-08-29 00:00:00.000'</span>,</span><br><span class="line"><span class="string">'M'</span>,</span><br><span class="line"><span class="string">'M'</span>,</span><br><span class="line"><span class="string">'1998-01-11 00:00:00.000'</span>,</span><br><span class="line"><span class="string">'2004-07-31 00:00:00.000'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--COMMIT TRAN</span></span><br><span class="line"><span class="comment">--ROLLBACK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--,DATABASE,S,</span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,OBJECT,IX,           </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,KEY,X,(3937e7935c85)   </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,KEY,X,(fa64829c6a59)   </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,KEY,X,(7e98e1db48bd)                 </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,PAGE,IX,1:24365           </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,PAGE,IX,1:24187          </span></span><br><span class="line"><span class="comment">--Employee_Demo_BTree,PAGE,IX,1:24363</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--（1）数据库上的S锁（resource_type=DATABASE）</span></span><br><span class="line"><span class="comment">--（2）表上的IX锁（resource_type=OBJECT）</span></span><br><span class="line"><span class="comment">--（3）每个索引上都要插入一条新数据，所以有一个key上的X锁</span></span><br><span class="line"><span class="comment">--（4）在每个索引上发生变化的那个页面，申请了一个IX锁（resource_type=PAGE）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>相对于select,update,delete，单条记录的insert操作对锁的申请比较简单。SQL会为新插入的数据本身申请一个X锁，在发生变化的页面上申请一个IX锁。由于这条记录是新插入的，被其他连接引用到的概率会相对小一些，所以出现阻塞的几率也要小</p>
]]></content>
      <categories>
        <category>knowledge</category>
      </categories>
      <tags>
        <tag>mssql</tag>
        <tag>lock</tag>
      </tags>
  </entry>
  <entry>
    <title>关于字符编码 unicode utf-8 utf-16 utf-32</title>
    <url>/2018/10/18/unicode/</url>
    <content><![CDATA[<p>字符编码的那些事…</p>
<a id="more"></a>

<h1 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h1><p>字符串编码跟数值编码有所不同,毕竟全球普及阿拉伯数字和10进制,数值的编码会相对简单些 : 每个国家的字符集都有所不同,而且在随时随刻的增加.</p>
<h2 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h2><p>ASCII 使用一个字节,精确点说是 0-127 来表示 128 个字符, 对于 英文来说足够了</p>
<table>
<thead>
<tr>
<th>ASCII值</th>
<th>控制字符</th>
<th>ASCII值</th>
<th>控制字符</th>
<th>ASCII值</th>
<th>控制字符</th>
<th>ASCII值</th>
<th>控制字符</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>NUT</td>
<td>32</td>
<td>(space)</td>
<td>64</td>
<td>@</td>
<td>96</td>
<td>、</td>
</tr>
<tr>
<td>1</td>
<td>SOH</td>
<td>33</td>
<td>!</td>
<td>65</td>
<td>A</td>
<td>97</td>
<td>a</td>
</tr>
<tr>
<td>2</td>
<td>STX</td>
<td>34</td>
<td>“</td>
<td>66</td>
<td>B</td>
<td>98</td>
<td>b</td>
</tr>
<tr>
<td>3</td>
<td>ETX</td>
<td>35</td>
<td>#</td>
<td>67</td>
<td>C</td>
<td>99</td>
<td>c</td>
</tr>
<tr>
<td>4</td>
<td>EOT</td>
<td>36</td>
<td>$</td>
<td>68</td>
<td>D</td>
<td>100</td>
<td>d</td>
</tr>
<tr>
<td>5</td>
<td>ENQ</td>
<td>37</td>
<td>%</td>
<td>69</td>
<td>E</td>
<td>101</td>
<td>e</td>
</tr>
<tr>
<td>6</td>
<td>ACK</td>
<td>38</td>
<td>&amp;</td>
<td>70</td>
<td>F</td>
<td>102</td>
<td>f</td>
</tr>
<tr>
<td>7</td>
<td>BEL</td>
<td>39</td>
<td>,</td>
<td>71</td>
<td>G</td>
<td>103</td>
<td>g</td>
</tr>
<tr>
<td>8</td>
<td>BS</td>
<td>40</td>
<td>(</td>
<td>72</td>
<td>H</td>
<td>104</td>
<td>h</td>
</tr>
<tr>
<td>9</td>
<td>HT</td>
<td>41</td>
<td>)</td>
<td>73</td>
<td>I</td>
<td>105</td>
<td>i</td>
</tr>
<tr>
<td>10</td>
<td>LF</td>
<td>42</td>
<td>*</td>
<td>74</td>
<td>J</td>
<td>106</td>
<td>j</td>
</tr>
<tr>
<td>11</td>
<td>VT</td>
<td>43</td>
<td>+</td>
<td>75</td>
<td>K</td>
<td>107</td>
<td>k</td>
</tr>
<tr>
<td>12</td>
<td>FF</td>
<td>44</td>
<td>,</td>
<td>76</td>
<td>L</td>
<td>108</td>
<td>l</td>
</tr>
<tr>
<td>13</td>
<td>CR</td>
<td>45</td>
<td>-</td>
<td>77</td>
<td>M</td>
<td>109</td>
<td>m</td>
</tr>
<tr>
<td>14</td>
<td>SO</td>
<td>46</td>
<td>.</td>
<td>78</td>
<td>N</td>
<td>110</td>
<td>n</td>
</tr>
<tr>
<td>15</td>
<td>SI</td>
<td>47</td>
<td>/</td>
<td>79</td>
<td>O</td>
<td>111</td>
<td>o</td>
</tr>
<tr>
<td>16</td>
<td>DLE</td>
<td>48</td>
<td>0</td>
<td>80</td>
<td>P</td>
<td>112</td>
<td>p</td>
</tr>
<tr>
<td>17</td>
<td>DCI</td>
<td>49</td>
<td>1</td>
<td>81</td>
<td>Q</td>
<td>113</td>
<td>q</td>
</tr>
<tr>
<td>18</td>
<td>DC2</td>
<td>50</td>
<td>2</td>
<td>82</td>
<td>R</td>
<td>114</td>
<td>r</td>
</tr>
<tr>
<td>19</td>
<td>DC3</td>
<td>51</td>
<td>3</td>
<td>83</td>
<td>S</td>
<td>115</td>
<td>s</td>
</tr>
<tr>
<td>20</td>
<td>DC4</td>
<td>52</td>
<td>4</td>
<td>84</td>
<td>T</td>
<td>116</td>
<td>t</td>
</tr>
<tr>
<td>21</td>
<td>NAK</td>
<td>53</td>
<td>5</td>
<td>85</td>
<td>U</td>
<td>117</td>
<td>u</td>
</tr>
<tr>
<td>22</td>
<td>SYN</td>
<td>54</td>
<td>6</td>
<td>86</td>
<td>V</td>
<td>118</td>
<td>v</td>
</tr>
<tr>
<td>23</td>
<td>TB</td>
<td>55</td>
<td>7</td>
<td>87</td>
<td>W</td>
<td>119</td>
<td>w</td>
</tr>
<tr>
<td>24</td>
<td>CAN</td>
<td>56</td>
<td>8</td>
<td>88</td>
<td>X</td>
<td>120</td>
<td>x</td>
</tr>
<tr>
<td>25</td>
<td>EM</td>
<td>57</td>
<td>9</td>
<td>89</td>
<td>Y</td>
<td>121</td>
<td>y</td>
</tr>
<tr>
<td>26</td>
<td>SUB</td>
<td>58</td>
<td>:</td>
<td>90</td>
<td>Z</td>
<td>122</td>
<td>z</td>
</tr>
<tr>
<td>27</td>
<td>ESC</td>
<td>59</td>
<td>;</td>
<td>91</td>
<td>[</td>
<td>123</td>
<td>{</td>
</tr>
<tr>
<td>28</td>
<td>FS</td>
<td>60</td>
<td>&lt;</td>
<td>92</td>
<td>/</td>
<td>124</td>
<td></td>
</tr>
<tr>
<td>29</td>
<td>GS</td>
<td>61</td>
<td>=</td>
<td>93</td>
<td>]</td>
<td>125</td>
<td>}</td>
</tr>
<tr>
<td>30</td>
<td>RS</td>
<td>62</td>
<td>&gt;</td>
<td>94</td>
<td>^</td>
<td>126</td>
<td>`</td>
</tr>
<tr>
<td>31</td>
<td>US</td>
<td>63</td>
<td>?</td>
<td>95</td>
<td>_</td>
<td>127</td>
<td>DEL</td>
</tr>
</tbody></table>
<p>特殊字符解释</p>
<table>
<thead>
<tr>
<th>特殊字符</th>
<th>解释</th>
<th>特殊字符</th>
<th>解释</th>
<th>特殊字符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>NUL</td>
<td>空</td>
<td>VT</td>
<td>垂直制表</td>
<td>SYN</td>
<td>空转同步</td>
</tr>
<tr>
<td>STX</td>
<td>正文开始</td>
<td>CR</td>
<td>回车</td>
<td>CAN</td>
<td>作废</td>
</tr>
<tr>
<td>ETX</td>
<td>正文结束</td>
<td>SO</td>
<td>移位输出</td>
<td>EM</td>
<td>纸尽</td>
</tr>
<tr>
<td>EOY</td>
<td>传输结束</td>
<td>SI</td>
<td>移位输入</td>
<td>SUB</td>
<td>换置</td>
</tr>
<tr>
<td>ENQ</td>
<td>询问字符</td>
<td>DLE</td>
<td>空格</td>
<td>ESC</td>
<td>换码</td>
</tr>
<tr>
<td>ACK</td>
<td>承认</td>
<td>DC1</td>
<td>设备控制1</td>
<td>FS</td>
<td>文字分隔符</td>
</tr>
<tr>
<td>BEL</td>
<td>报警</td>
<td>DC2</td>
<td>设备控制2</td>
<td>GS</td>
<td>组分隔符</td>
</tr>
<tr>
<td>BS</td>
<td>退一格</td>
<td>DC3</td>
<td>设备控制3</td>
<td>RS</td>
<td>记录分隔符</td>
</tr>
<tr>
<td>HT</td>
<td>横向列表</td>
<td>DC4</td>
<td>设备控制4</td>
<td>US</td>
<td>单元分隔符</td>
</tr>
<tr>
<td>LF</td>
<td>换行</td>
<td>NAK</td>
<td>否定</td>
<td>DEL</td>
<td>删除</td>
</tr>
</tbody></table>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>每个国家指定了自己的编码方式 比如 中文的 Big5 GB2312 , ISO-8859-x 系列等. 这样就非常不方便了:</p>
<ul>
<li>GB2312 “中”编码为: D6D0</li>
<li>阿拉伯编码(ISO 8859-6)中 D6D0 表示 : ضذ</li>
</ul>
<p>非常不方便. 因此制定了Unicode标准,用来定义字符编码.</p>
<h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>Unicode是一个字符集 里面规定了世界上每个字符对应的二进制代码 至于这个二进制代码如何存储则没有任何规定.</p>
<p>Unicode 前面的字符可能只需要一个字节表示,例如: “A”, 后面需要两个字节, 例如 “汉” 的 Unicode 是 0x6c49 (110110001001001),需要 15 位 即 2个字节存储,更后面的字符可能更长如 3个字节甚至4个字节.</p>
<p>如果使用不定长存储:这时候就不能确定3个字节到底是1个字符(3字节长度),还是2个字符(1字节字符+2字节字符)</p>
<p>如果使用定长字节存储Unicode,比如 使用4个字节 则会造成浪费.</p>
<p>因此出现了UTF-8 UTF-16 UTF-32 等 存储方案:</p>
<h2 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h2><table>
<thead>
<tr>
<th>Unicode(0x)</th>
<th>UTF-8</th>
</tr>
</thead>
<tbody><tr>
<td>0000 0000 - 0000 007F</td>
<td>0xxxxxxx</td>
</tr>
<tr>
<td>0000 0080 - 0000 07FF</td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0000 0800 - 0000 FFFF</td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0001 0000 - 0010 FFFF</td>
<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody></table>
<p>规则 :</p>
<ol>
<li>单个字节字符，第一位 0，剩余 7 位对应字符的 Unicode 码点。</li>
<li>多个字节字符，需要几个字节，从头开始就有几个连续的 1，一个UTF-8编码组的其他的字节开头都是10，其余的位从右向左填充字符的 Unicode 码点</li>
</ol>
<h2 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h2><p>UTF-16使用2个字节或4个字节表示一个Unicode : 根据 Unicode 码点范围:</p>
<ul>
<li>U+0x00000000 - U+0x0000FFFF : 使用2个字节表示，码点即UTF-16编码</li>
<li>U+0x00010000 - U+0x0010FFFF : 使用4个字节表示，首先计算 U’= Unicode -0x10000 然后表示为 20位2进制（Unicode 最大码点位是0x10FFFF 减去 0x10000 等于 0xFFFFF,因此可以表示为20位2进制）: yyyy yyyy yyxx xxxx xxxx,则 UTF-16 编码就是 110110yyyyyyyyyy 110111xxxxxxxxxx</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">H = <span class="built_in">Math</span>.floor((c<span class="number">-0x10000</span>) / <span class="number">0x400</span>)+<span class="number">0xD800</span></span><br><span class="line">L = (c - <span class="number">0x10000</span>) % <span class="number">0x400</span> + <span class="number">0xDC00</span></span><br></pre></td></tr></table></figure>

<p>当读取时候</p>
<ul>
<li>UTF-16中2个字节成为一个WORD，因此看到一个WORD属于范围 DB80(1101100000000000)－DBFF，那么紧接着的WORD肯定属于范围DC00(1101110000000000)－DFFF ，这两个WORD 是一个字符.</li>
<li>如果一个WORD 小于 DB80 ，那么这个WORD 自成一个字符.</li>
</ul>
<h2 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h2><p>UTF-32编码以32位无符号整数为单位。Unicode的UTF-32编码就是其对应的32位无符号整数。</p>
<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><p><a href="./2.1.md#字节序">前面</a>讲到字节序,一个字符的编码可能涉及到多个字节,因此当存储时也需要定义字节序</p>
<table>
<thead>
<tr>
<th>Unicode</th>
<th>UTF-16LE</th>
<th>UTF-16BE</th>
<th>UTF32-LE</th>
<th>UTF32-BE</th>
</tr>
</thead>
<tbody><tr>
<td>0x006C49</td>
<td>49 6C</td>
<td>6C 49</td>
<td>49 6C 00 00</td>
<td>00 00 6C 49</td>
</tr>
<tr>
<td>0x020C30</td>
<td>43 D8 30 DC</td>
<td>D8 43 DC 30</td>
<td>30 0C 02 00</td>
<td>00 02 0C 30</td>
</tr>
</tbody></table>
<blockquote>
<p>UTF-8 不需要字节序 : 因为 UTF-8 肯定是 110xxxxx , 1110xxxx 这样的高字节在前, 这样才能知道需要读取后面的几个字节.也可以理解为 UTF-8 只有 大端字节序</p>
</blockquote>
<p>UTF-16,UTF-32 则使用 FEFF (零宽无中断空格) 这个字符作为 BOM , 在传输时候首先传输这个字符 , 用来标识 UTF-16 / 32的字节序.</p>
<p>FEFF 小端为 FFFE（UTF-16）和FFFE0000（UTF-32）, 在Unicode中都是未定义的码位,不会出现在实际传输中,只会在开头出现.因此只要碰到 FEFF 或者 FFFE 就认为是 字节流的开头.</p>
<p>UTF-16/32 传输和存储时首先传输 BOM 字节 用来确定字节序,UTF-8 不需要,但是也可以为了保持统一传输 EF BB BF (‭FEFF‬)</p>
<table>
<thead>
<tr>
<th>UTF</th>
<th>BOM</th>
</tr>
</thead>
<tbody><tr>
<td>UTF-8 without BOM</td>
<td></td>
</tr>
<tr>
<td>UTF-8 with BOM</td>
<td>EF BB BF</td>
</tr>
<tr>
<td>UTF-16LE</td>
<td>FF FE</td>
</tr>
<tr>
<td>UTF-16BE</td>
<td>FE FF</td>
</tr>
<tr>
<td>UTF-32LE</td>
<td>FF FE 00 00</td>
</tr>
<tr>
<td>UTF-32BE</td>
<td>00 00 FE FF</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>knowledge</category>
      </categories>
      <tags>
        <tag>unicode</tag>
        <tag>utf-8/16/32</tag>
      </tags>
  </entry>
  <entry>
    <title>sql server 锁(1)</title>
    <url>/2017/03/21/sql-server-locks/</url>
    <content><![CDATA[<p>介绍 SQL Server 的锁，阻塞以及死锁等问题。</p>
<a id="more"></a>

<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#锁、阻塞、死锁">锁、阻塞、死锁</a></li>
<li><a href="#锁资源和兼容性">锁资源和兼容性</a></li>
<li><a href="#事务隔离级别和锁释放">事务隔离级别和锁释放</a></li>
</ul>
<h1 id="锁、阻塞、死锁"><a href="#锁、阻塞、死锁" class="headerlink" title="锁、阻塞、死锁"></a>锁、阻塞、死锁</h1><p>事务是关系型数据库的一个基础概念。他是作为单个逻辑工作单元执行的一系列操作一个逻辑工作单元必须有4个属性，称为原子性，<br>一致性，隔离性，持久性(ACID)只有这样才能成为一个事务.</p>
<ul>
<li>原子性</li>
</ul>
<p>事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。比如一个事务要修改100条记录，要不就100条都修改，要不就都不修改。不能发生只修改了其中50条，另外50条没有改的情况。</p>
<ul>
<li>一致性</li>
</ul>
<p>事务在完成时，必须使所有的数据都保持一致状态。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。事务结束时，所有的内部数据结构（如B树索引或双向链表）都必须是正确的。</p>
<ul>
<li>隔离性</li>
</ul>
<p>由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务识别数据所处的状态，要么是另一并发事务修改他之前的状态，要么是第二个事务修改他之后的状态，事务不会识别中间状态的数据。也就是说，虽然用户是在并发操作，但是，事务是串行执行的。对同一个数据对象的操作，事务读写修改是有先后顺序的。不是同一时间什么事情都能同时做的。</p>
<ul>
<li>持久性</li>
</ul>
<p>事务完成之后，他对于系统的影响是永久性的。哪怕SQL发生了异常终止，机器掉电，只要数据库文件还是完好的，事务做的修改必须还全部存在。</p>
<p>以上事务的定义对所有的关系型数据库都成立，不管是SQLSERVER，还是DB2，ORACLE，都要遵从这些限制。但是，不同的数据库系统在事务的实现机制上有所不同，索引产生的效果在细节上是有差异的。尤其是SQLSERVER和ORACLE，在事务的实现上有很大不同。两者在不同的应用场景上各有优劣，不好讲谁做得更好，谁做得更差。下面讲的是SQLSERVER实现事务的方法。</p>
<p>要实现业务逻辑上的ACID，有两方面任务：</p>
<p>1、数据库程序员要负责启动和结束事务，确定一个事务的范围:程序员要定义数据修改的顺序，将组织的业务规则用TSQL语句表现出来，然后将这些语句包括到一个事务中。换句话说，数据库程序员负责在必要并且合适的时间开启一个事务，将要做的操作以正确的顺序提交给SQLSERVER，然后在合适的时间结束这个事务。</p>
<p>2、SQLSERVER数据库引擎强制该事务的物理完整性:数据库引擎有能力提供一种机制，保证每个逻辑事务的物理完整性SQLSERVER通过下面方法做到：</p>
<ul>
<li>锁定资源，使事务保持隔离</li>
</ul>
<p>SQLSERVER通过在访问不同资源时需要申请不同类型锁的方式，实现了不同事务之间的隔离。如果两个事务会互相影响，那么在其中一个事务申请到了锁以后，另外一个事务就必须等待，直到前一个事务做完为止。</p>
<ul>
<li>先写入日志方式，保证事务的持久性</li>
</ul>
<p>SQLSERVER通过先写入日志的方式，保证所有提交了的事务在硬盘上的日志文件里都有记录。即使服务器硬件，操作系统或数据库引擎实例自身出现故障，该实例也可以在重新启动时使用事务日志，将所有未完成的事务自动地回滚到系统出现故障的点，使得数据库进入一个从事务逻辑上来讲一致的状态。</p>
<ul>
<li>事务管理特性，强制保证事务的原子性和一致性</li>
</ul>
<p>事务启动后，就必须成功完成，否则数据库引擎实例将撤销该事务启动之后对数据所做的所有修改。</p>
<p>如果一个连接没有提交事务，SQL会保持这个事务一直在活动状态，并且不在意这个事务的长短或这个连接是否还在活动，直到这个连接自己提交事务，或登出（logout）SQLSERVER如果在登出的时候还有未提交的事务，SQL会把这个事务范围内所做的所有操作撤销（回滚）。</p>
<p>所以，锁是SQL实现事务隔离的一部分，阻塞正是事务隔离的体现。要实现事务的隔离，阻塞不是SQLSERVER自找的，而是事务对SQLSERVER提出的要求，也是用户使用事务要付出的代价一个数据库开发者和DBA的工作，不是去消除阻塞，而是要把阻塞的时间和范围控制在一个合理的范围之内，使最终用户既能享受事务的ACID，又能享受预期的性能。完全消除阻塞，是不可能的事情。</p>
<p>换句话说，阻塞是实现事务的隔离所带来的不可避免的代价。为了达到良好的性能，数据库开发者和DBA要把阻塞的时间和范围控制在一个合理的范围之内。这不是一件很简单的工作，所以阻塞也将会是SQLSERVER的永恒的话题之一。</p>
<p>阻塞和死锁是两个不同的概念:</p>
<ul>
<li><p>阻塞是由于资源不足引起的排队等待现象。</p>
</li>
<li><p>死锁是由于两个对象在拥有一份资源的情况下申请另一份资源，而另一份资源恰好又是这两对象正持有的，导致两对象无法完成操作，且所持资源无法释放。例如：</p>
<ul>
<li>事务 A 获取了行 1 的共享锁。</li>
<li>事务 B 获取了行 2 的共享锁。</li>
<li>现在，事务 A 请求行 2 的排他锁，但在事务 B 完成并释放其对行 2 持有的共享锁之前被阻塞。</li>
<li>现在，事务 B 请求行 1 的排他锁，但在事务 A 完成并释放其对行 1 持有的共享锁之前被阻塞。</li>
</ul>
</li>
</ul>
<p>对于一个多用户数据库系统，尤其是大量用户通过不同应用程序同时访问同一个数据库的系统如果发生一个或多个以下现象，管理员就应该检查是否遇到了阻塞或者死锁了:</p>
<ul>
<li><p>并发用户少的时候，一切正常。但是随着并发用户的增加，性能越来越慢</p>
</li>
<li><p>客户端经常收到以下错误</p>
<ul>
<li><p>错误1222:已经超过了锁请求超时时段</p>
</li>
<li><p>错误1205:事务（进程ID XXX）与另一个进程被死锁在XX资源上，并且已被选作死锁牺牲品。请重新运行该事务</p>
</li>
<li><p>超时错误:timeout expired.the timeout period elapsed prior to completion of the operation orthe server is not responding</p>
</li>
</ul>
</li>
<li><p>应用程序运行很慢，但是SQL这里CPU和硬盘利用率很低。DBA运行sp_who或sp_who2这样的短小命令很快返回</p>
</li>
<li><p>有些查询能够进行，但是有些特定的查询或修改总是不能返回</p>
</li>
<li><p>重启SQL就能解决。但是有可能跑一段时间以后又会出问题</p>
</li>
</ul>
<p>锁在一个连接里的生命周期是和事务的生命周期紧密相连的，数据结构不同，SQLSERVER需要申请的锁<br>的数量也会不同</p>
<p>造成阻塞和死锁的3大原因：</p>
<ul>
<li>连接持有锁时间过长</li>
<li>锁数目过多</li>
<li>锁粒度过大</li>
</ul>
<p>至于如何才能避免产生严重的阻塞和死锁问题，应该从下面3个方面着手:</p>
<ul>
<li>申请资源的互斥度:如果不同的连接申请的锁都是相互兼容的，那么他们就不会产生阻塞</li>
<li>锁的范围和数目的多少:做同样一件事情，SQLSERVER申请的锁的粒度和数目可能会不一样。一个良好设计的程序可以使申请的锁的粒度和数目控制在最小的范围之内。这样，阻塞住别人的可能性就能大大降低</li>
<li>事务持有锁资源的时间长短:如果一个锁是大家都需要用的，那么每个人持有他的时间越短，阻塞对性能的影响就会越小。最好是申请得越晚越好，释放得越早越好</li>
</ul>
<p>为了达到以上3个目的，需要研究一下SQLSERVER的锁资源模式和兼容性，以及他们怎么被申请和释放的。</p>
<h1 id="锁资源和兼容性"><a href="#锁资源和兼容性" class="headerlink" title="锁资源和兼容性"></a>锁资源和兼容性</h1><h2 id="锁粒度和层次结构"><a href="#锁粒度和层次结构" class="headerlink" title="锁粒度和层次结构"></a>锁粒度和层次结构</h2><p>下表列出了数据库引擎可以锁定的资源。</p>
<table>
<thead>
<tr>
<th align="center">资源</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">RID</td>
<td align="center">用于锁定堆中的单个行的行标识符。</td>
</tr>
<tr>
<td align="center">KEY</td>
<td align="center">索引中用于保护可序列化事务中的键范围的行锁。</td>
</tr>
<tr>
<td align="center">PAGE</td>
<td align="center">数据库中的 8 KB 页，例如数据页或索引页。</td>
</tr>
<tr>
<td align="center">EXTENT</td>
<td align="center">一组连续的八页，例如数据页或索引页。</td>
</tr>
<tr>
<td align="center">HoBT</td>
<td align="center">堆或 B 树。 用于保护没有聚集索引的表中的 B 树（索引）或堆数据页的锁。</td>
</tr>
<tr>
<td align="center">TABLE</td>
<td align="center">包括所有数据和索引的整个表。</td>
</tr>
<tr>
<td align="center">FILE</td>
<td align="center">数据库文件。</td>
</tr>
<tr>
<td align="center">APPLICATION</td>
<td align="center">应用程序专用的资源。</td>
</tr>
<tr>
<td align="center">METADATA</td>
<td align="center">元数据锁。</td>
</tr>
<tr>
<td align="center">ALLOCATION_UNIT</td>
<td align="center">分配单元。</td>
</tr>
<tr>
<td align="center">DATABASE</td>
<td align="center">整个数据库。</td>
</tr>
</tbody></table>
<h2 id="锁模式"><a href="#锁模式" class="headerlink" title="锁模式"></a>锁模式</h2><table>
<thead>
<tr>
<th align="center">锁模式</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">共享 (S)</td>
<td align="center">用于不更改或不更新数据的读取操作，如 SELECT 语句。</td>
</tr>
<tr>
<td align="center">更新 (U)</td>
<td align="center">用于可更新的资源中。 防止当多个会话在读取、锁定以及随后可能进行的资源更新时发生常见形式的死锁。</td>
</tr>
<tr>
<td align="center">排他 (X)</td>
<td align="center">用于数据修改操作，例如 INSERT、UPDATE 或 DELETE。 确保不会同时对同一资源进行多重更新。</td>
</tr>
<tr>
<td align="center">意向</td>
<td align="center">用于建立锁的层次结构。 意向锁包含三种类型：意向共享 (IS)、意向排他 (IX) 和意向排他共享 (SIX)。</td>
</tr>
<tr>
<td align="center">架构</td>
<td align="center">在执行依赖于表架构的操作时使用。 架构锁包含两种类型：架构修改 (Sch-M) 和架构稳定性 (Sch-S)。</td>
</tr>
<tr>
<td align="center">大容量更新 (BU)</td>
<td align="center">在向表进行大容量数据复制且指定了 TABLOCK 提示时使用。</td>
</tr>
<tr>
<td align="center">键范围</td>
<td align="center">当使用可序列化事务隔离级别时保护查询读取的行的范围。 确保再次运行查询时其他事务无法插入符合可序列化事务的查询的行。</td>
</tr>
</tbody></table>
<h3 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h3><p>共享锁（S 锁）允许并发事务在封闭式并发控制下读取 (SELECT) 资源。 有关详细信息，请参阅并发控制的类型。 资源上存在共享锁（S 锁）时，任何其他事务都不能修改数据。 读取操作一完成，就立即释放资源上的共享锁（S 锁），除非将事务隔离级别设置为可重复读或更高级别，或者在事务持续时间内用锁定提示保留共享锁（S 锁）。</p>
<h3 id="更新锁"><a href="#更新锁" class="headerlink" title="更新锁"></a>更新锁</h3><p>更新锁（U 锁）可以防止常见的死锁。 在可重复读或可序列化事务中，此事务读取数据 [获取资源（页或行）的共享锁（S 锁）]，然后修改数据 [此操作要求锁转换为排他锁（X 锁）]。 如果两个事务获得了资源上的共享模式锁，然后试图同时更新数据，则一个事务尝试将锁转换为排他锁（X 锁）。 共享模式到排他锁的转换必须等待一段时间，因为一个事务的排他锁与其他事务的共享模式锁不兼容；发生锁等待。 第二个事务试图获取排他锁（X 锁）以进行更新。 由于两个事务都要转换为排他锁（X 锁），并且每个事务都等待另一个事务释放共享模式锁，因此发生死锁。<br>若要避免这种潜在的死锁问题，请使用更新锁（U 锁）。 一次只有一个事务可以获得资源的更新锁（U 锁）。 如果事务修改资源，则更新锁（U 锁）转换为排他锁（X 锁）。</p>
<h3 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h3><p>排他锁（X 锁）可以防止并发事务对资源进行访问。 使用排他锁（X 锁）时，任何其他事务都无法修改数据；仅在使用 NOLOCK 提示或未提交读隔离级别时才会进行读取操作。<br>数据修改语句（如 INSERT、UPDATE 和 DELETE）合并了修改和读取操作。 语句在执行所需的修改操作之前首先执行读取操作以获取数据。 因此，数据修改语句通常请求共享锁和排他锁。 例如，UPDATE 语句可能根据与一个表的联接修改另一个表中的行。 在此情况下，除了请求更新行上的排他锁之外，UPDATE 语句还将请求在联接表中读取的行上的共享锁。</p>
<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>数据库引擎使用意向锁来保护共享锁（S 锁）或排他锁（X 锁）放置在锁层次结构的底层资源上。 意向锁之所以命名为意向锁，是因为在较低级别锁前可获取它们，因此会通知意向将锁放置在较低级别上。<br>意向锁有两种用途：<br>防止其他事务以会使较低级别的锁无效的方式修改较高级别资源。<br>提高数据库引擎在较高的粒度级别检测锁冲突的效率。<br>例如，在该表的页或行上请求共享锁（S 锁）之前，在表级请求共享意向锁。 在表级设置意向锁可防止另一个事务随后在包含那一页的表上获取排他锁（X 锁）。 意向锁可以提高性能，因为数据库引擎仅在表级检查意向锁来确定事务是否可以安全地获取该表上的锁。 而不需要检查表中的每行或每页上的锁以确定事务是否可以锁定整个表。<br>意向锁包括意向共享 (IS)、意向排他 (IX) 以及意向排他共享 (SIX)。</p>
<table>
<thead>
<tr>
<th align="center">锁模式</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">意向共享 (IS)</td>
<td align="center">保护针对层次结构中某些（而并非所有）低层资源请求或获取的共享锁。</td>
</tr>
<tr>
<td align="center">意向排他 (IX)</td>
<td align="center">保护针对层次结构中某些（而并非所有）低层资源请求或获取的排他锁。 IX 是 IS 的超集，它也保护针对低层级别资源请求的共享锁。</td>
</tr>
<tr>
<td align="center">意向排他共享 (SIX)</td>
<td align="center">保护针对层次结构中某些（而并非所有）低层资源请求或获取的共享锁以及针对某些（而并非所有）低层资源请求或获取的意向排他锁。 顶级资源允许使用并发 IS锁,例如，获取表上的 SIX 锁也将获取正在修改的页上的意向排他锁以及修改的行上的排他锁。 虽然每个资源在一段时间内只能有一个 SIX 锁，以防止其他事务对资源进行更新，但是其他事务可以通过获取表级的 IS 锁来读取层次结构中的低层资源。</td>
</tr>
<tr>
<td align="center">意向更新 (IU)</td>
<td align="center">保护针对层次结构中所有低层资源请求或获取的更新锁。 仅在页资源上使用 IU 锁。 如果进行了更新操作，IU 锁将转换为 IX 锁。</td>
</tr>
<tr>
<td align="center">共享意向更新 (SIU)</td>
<td align="center">S 锁和 IU 锁的组合，作为分别获取这些锁并且同时持有两种锁的结果。 例如，事务执行带有 PAGLOCK 提示的查询，然后执行更新操作。 带有 PAGLOCK 提示的查询将获取 S 锁，更新操作将获取 IU 锁。</td>
</tr>
<tr>
<td align="center">更新意向排他 (UIX)</td>
<td align="center">U 锁和 IX 锁的组合，作为分别获取这些锁并且同时持有两种锁的结果。</td>
</tr>
</tbody></table>
<h2 id="锁兼容性"><a href="#锁兼容性" class="headerlink" title="锁兼容性"></a>锁兼容性</h2><img src="/2017/03/21/sql-server-locks/001.png" class="" title="锁兼容模式">

<p>完整的锁兼容性矩阵</p>
<img src="/2017/03/21/sql-server-locks/002.gif" class="" title="完整的锁兼容性矩阵">

<h2 id="键范围锁定"><a href="#键范围锁定" class="headerlink" title="键范围锁定"></a>键范围锁定</h2><p><a href="https://msdn.microsoft.com/zh-cn/library/ms191272.aspx" target="_blank" rel="noopener">键范围锁定</a></p>
<h1 id="事务隔离级别和锁释放"><a href="#事务隔离级别和锁释放" class="headerlink" title="事务隔离级别和锁释放"></a>事务隔离级别和锁释放</h1><p>数据库有并发操作的时候，修改数据的事务会影响同时要去读取或修改相同数据的其他事务。如果数据存储系统并没有并发控制，则事务可能会看到以下负面影响：</p>
<ul>
<li>丢失更新</li>
<li>未提交的依赖关系（脏读）</li>
<li>不一致的分析（不可重复读）</li>
<li>幻读</li>
</ul>
<p>上面4种情况的定义可以在SQL联机丛书里找到。当许多人试图同时修改数据库中的数据时，必须实现一个控制系统，使一个人所做的修改不会对他人所做的修改产生负面影响，这就称为并发控制。</p>
<p>需要注意的是，不同性质的应用程序对并发控制会有不一样的需求。例如一个银行ATM系统，可能就不允许不可重复读的出现。而一个报表系统，可能对脏读的敏感度不会那么高。要防止的负面<br>影响越多，隔离级别就越高，程序的并发性也就越差。并不是每个应用程序都需要将上面4种问题全部避免。</p>
<p>数据库系统通过定义事务的隔离级别来定义使用哪一级的并发控制。SQL-99标准定义了下列隔离级别，SQL数据库引擎支持所有这些隔离级别：</p>
<ul>
<li>未提交读（隔离事务的最低级别，只能保证不读取物理上损坏的数据）</li>
<li>已提交读（数据库引擎的默认级别，可以防止脏读）</li>
<li>可重复读</li>
<li>可序列化（隔离事务的最高级别，可防止幻影，事务之间完全隔离）</li>
</ul>
<p>表 ：不同隔离级别允许的并发副作用<br>|隔离级别|               |脏读            |不可重复读                       |幻读|<br>| :——————–:| :—————–: |:—————–: |:—————–: |<br>|未提交读(nolock)        |否                 |是                            |是|<br>|已提交读                |否                 |是                            |是|<br>|可重复读                |否                 |否                            |是|<br>|可序列化                |否                 |否                            |否|</p>
<h3 id="未提交读（read-uncommitted）"><a href="#未提交读（read-uncommitted）" class="headerlink" title="未提交读（read uncommitted）"></a>未提交读（read uncommitted）</h3><p>指定语句可以读取已由其他事务修改但尚未提交的行。也就是说，允许脏读<br>在read uncommitted级别运行的事务，不会发出共享锁来防止其他事务修改当前事务读取的数据。read committed事务也不会被排他锁阻塞。共享锁会禁止当前事务读取其他事务已修改但尚未提交的行。设置此选项后，此事务可以读取其他事务未提交的修改。在事务结束之前，其他事务可以更改数据中的值。该选项的作用与在事务内所有select语句中的所有表上设置nolock相同。这是隔离级别中限制最少的级别。<br>换句话说，未提交读的意思也就是：读的时候不申请共享锁。所以他不会被其他人的排他锁阻塞，他也不会阻塞别人申请排他锁</p>
<h3 id="已提交读（read-committed）"><a href="#已提交读（read-committed）" class="headerlink" title="已提交读（read committed）"></a>已提交读（read committed）</h3><p>指定语句不能读取已由其他事务修改但尚未提交的数据.这样可以避免脏读。其他事务可以在当前事务的各个语句之间更改数据，从而产生不可重复读取数据和幻象数据。该选项是SQL的默认设置。<br>数据库引擎会在读的时候使用共享锁防止其他事务在当前事务执行读取操作期间修改行。共享锁还会阻止语句在其他事务完成之前读取由这些事务修改的行。但是，语句运行完毕后便会释放共享锁，而不是等到事务提交的时候但是SQL默认设置是每一语句运行完毕就提交事务。</p>
<h3 id="可重复读（repeatable-read）"><a href="#可重复读（repeatable-read）" class="headerlink" title="可重复读（repeatable read）"></a>可重复读（repeatable read）</h3><p>指定语句不能读取已由其他事务修改但尚未提交的行，并且指定，其他任何事务都不能在当前事务完成之前修改由当前事务读取的数据。<br>在这个隔离级别上，对事务中的每个语句所读取的全部数据都设置了共享锁，并且该共享锁一直保持到事务完成为止。这样可以防止其他事务修改当前事务读取的任何行。其他事务可以插入与当前事务所发出语句的搜索条件相匹配的新行。如果当前事务随后重试执行该语句，他会检索新行，从而产生幻读。<br>由于共享锁一直保持到事务结束，而不是每个语句结束时释放，所以并发性低于默认的read committed隔离级别。此选项只在必要时使用。</p>
<h3 id="可序列化（serializable）"><a href="#可序列化（serializable）" class="headerlink" title="可序列化（serializable）"></a>可序列化（serializable）</h3><p>可序列化的要求：<br>语句不能读取已由其他事务修改但尚未提交的数据。<br>任何其他事务都不能在当前事务完成之前修改由当前事务读取的数据在当前事务完成之前，其他事务不能使用当前事务中任何语句读取的键值插入新行。<br>SQL通过加范围锁的方式来实现可序列化。范围锁处于与事务中执行的每个语句的搜索条件相匹配的键值范围之内。这样可以阻止其他事务更新或插入任何行，从而限定当前事务所执行的任何语句。这意味着如果再次执行事务中的任何语句，则这些语句便会读取同一组行。在事务完成之前将一直保持范围锁。<br>这是限制最多的隔离级别，因为他锁定了键的整个范围，并在事务完成之前一直保持范围锁。因为并发级别最低，所以应只在必要时才使用该选项。该选项的作用与在事务内所有select语句中的所有表上设置holdlock相同。</p>
<p>SQLSERVER其实通过对共享锁申请和释放机制的不同处理，来实现不同事务隔离级别的</p>
<p>不同隔离级别对共享锁的不同处理方式：</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">是否申请共享锁</th>
<th align="center">何时释放</th>
<th align="center">有无范围锁</th>
</tr>
</thead>
<tbody><tr>
<td align="center">未提交读</td>
<td align="center">不申请</td>
<td align="center">无</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">已提交读</td>
<td align="center">申请</td>
<td align="center">当前语句做完时</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">可重复读</td>
<td align="center">申请</td>
<td align="center">事务提交时</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">可序列化</td>
<td align="center">申请</td>
<td align="center">事务提交时</td>
<td align="center">有</td>
</tr>
</tbody></table>
<p>也就是说，事务隔离级别越高，共享锁被持有的时间越长。而可序列化还要申请粒度更高的范围锁，并一直持有到事务结束。所以，如果阻塞发生在共享锁上面，可以通过降低事务隔离级别得到缓解。</p>
<p>需要说明的是，SQL在处理排他锁的时候，4个事务隔离级别都是一样的。都是在修改的时候申请直到事务提交的时候释放（而不是语句结束以后就立即释放）。如果阻塞是发生在排他锁上面，是不能通过降低事务隔离级别得到缓解的。</p>
]]></content>
      <categories>
        <category>knowledge</category>
      </categories>
      <tags>
        <tag>mssql</tag>
        <tag>lock</tag>
      </tags>
  </entry>
</search>
